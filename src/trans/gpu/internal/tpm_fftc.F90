! (C) Copyright 2014- ECMWF.
! (C) Copyright 2022- NVIDIA.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE TPM_FFTC

!   Author.
!   -------
!     George Mozdzynski
!
!   Modifications.
!   -------------- 
!     Original      October 2014

USE, INTRINSIC :: ISO_C_BINDING

USE PARKIND_ECTRANS, ONLY: JPIM, JPRBT
USE MPL_MODULE, ONLY : MPL_MYRANK

IMPLICIT NONE

SAVE

PRIVATE
PUBLIC CREATE_PLAN_FFT, DESTROY_PLAN_FFT, DESTROY_ALL_PLANS_FFT, INIT_PLANS_FFT, &
      & FFTC_RESOL, TC

TYPE FFTC_TYPE
  INTEGER(KIND=JPIM),POINTER :: N_PLANS(:)
  TYPE(FFTC_PLAN),POINTER :: FFTC_PLANS(:)
  INTEGER(KIND=JPIM) :: N_MAX=0
  INTEGER(KIND=JPIM) :: N_MAX_PLANS=8
END TYPE FFTC_TYPE


TYPE FFTC_PLAN
  INTEGER(KIND=JPIM) :: NPLAN_ID=123456
  INTEGER(KIND=JPIM) :: NPLAN
  INTEGER(KIND=JPIM) :: NLOT
  INTEGER(KIND=JPIM) :: NSTRIDE
  INTEGER(KIND=JPIM) :: NTYPE
  TYPE(FFTC_PLAN),POINTER :: NEXT_PLAN => NULL()
END TYPE FFTC_PLAN

TYPE(FFTC_TYPE),ALLOCATABLE,TARGET :: FFTC_RESOL(:)
TYPE(FFTC_TYPE),POINTER     :: TC



! ------------------------------------------------------------------
CONTAINS
! ------------------------------------------------------------------


SUBROUTINE INIT_PLANS_FFT(KDLON)
INTEGER(KIND=JPIM),INTENT(IN) :: KDLON

TC%N_MAX=KDLON
ALLOCATE(TC%FFTC_PLANS(TC%N_MAX))
ALLOCATE(TC%N_PLANS(TC%N_MAX))
TC%N_PLANS(:)=0
RETURN  
END SUBROUTINE INIT_PLANS_FFT


SUBROUTINE CREATE_PLAN_FFT(KPLAN,KTYPE,KN,KLOT,KSTRIDE)
INTEGER(KIND=JPIM),INTENT(OUT) :: KPLAN
INTEGER(KIND=JPIM),INTENT(IN) :: KTYPE,KN,KLOT,KSTRIDE

INTEGER(KIND=JPIM) :: IPLAN
INTEGER(KIND=JPIM) :: IRANK, ISTRIDE
INTEGER(KIND=JPIM) :: JL, JN
INTEGER(KIND=JPIM) :: IRDIST,ICDIST,IN(1),IEMBED(1)
LOGICAL :: LLFOUND
LOGICAL :: LLRESTRICT_PLANS=.TRUE.
TYPE(FFTC_PLAN),POINTER :: CURR_FFTC_PLAN,START_FFTC_PLAN
INTERFACE
  SUBROUTINE CREATE_PLAN_FFTC(KPLAN,KTYPE,KN,KLOT,KSTRIDE) BIND(C,NAME="create_plan_fftc_")
   USE, INTRINSIC :: ISO_C_BINDING
   INTEGER(C_INT) :: KPLAN
   INTEGER(C_INT) :: KTYPE,KN,KLOT,KSTRIDE
  END SUBROUTINE CREATE_PLAN_FFTC
END INTERFACE

IF( KN > TC%N_MAX )THEN
  CALL ABOR1('CREATE_PLAN_FFT: KN > N_MAX THAT WAS INITIALISED IN INIT_PLANS_FFTC')
ENDIF

IRANK=1
ISTRIDE=1
IN(1)=KN
IEMBED(1)=IN(1)
ICDIST=KN/2+1
IRDIST=ICDIST*2

!!$OMP CRITICAL
LLFOUND=.FALSE.
IF( TC%FFTC_PLANS(KN)%NPLAN_ID /= 123456 )THEN
  WRITE(*,'("CREATE_PLAN_FFT.1: PLAN_ID=",I10)')TC%FFTC_PLANS(KN)%NPLAN_ID
  CALL ABOR1('CREATE_PLAN_FFT.1: NPLAN_ID /= 123456')
ENDIF
CURR_FFTC_PLAN=>TC%FFTC_PLANS(KN)
IF( CURR_FFTC_PLAN%NPLAN_ID /= 123456 )THEN
  WRITE(*,'("CREATE_PLAN_FFT.2: PLAN_ID=",I10)')CURR_FFTC_PLAN%NPLAN_ID
  CALL ABOR1('CREATE_PLAN_FFT.2: NPLAN_ID /= 123456')
ENDIF
! search for plan in existing plans
DO JL=1,TC%N_PLANS(KN)
  IF( KLOT == CURR_FFTC_PLAN%NLOT .AND. KTYPE == CURR_FFTC_PLAN%NTYPE .AND. KSTRIDE == CURR_FFTC_PLAN%NSTRIDE )THEN
    LLFOUND=.TRUE.
    IPLAN=CURR_FFTC_PLAN%NPLAN
    EXIT
  ELSEIF( JL /= TC%N_PLANS(KN) )THEN
    CURR_FFTC_PLAN=>CURR_FFTC_PLAN%NEXT_PLAN
    IF( CURR_FFTC_PLAN%NPLAN_ID /= 123456 )THEN
      WRITE(*,'("CREATE_PLAN_FFT.3: PLAN_ID=",I10)')CURR_FFTC_PLAN%NPLAN_ID
      CALL ABOR1('CREATE_PLAN_FFT.3: NPLAN_ID /= 123456')
    ENDIF
  ENDIF
ENDDO
IF( .NOT.LLFOUND )THEN
  IF( LLRESTRICT_PLANS )THEN
    IF( TC%N_PLANS(KN) == TC%N_MAX_PLANS )THEN
      ! destroy the plan at the start of the list
!     WRITE(*,'("CREATE_PLAN_FFT: BEG: DESTROYING A PLAN AT THE START OF THE LIST")')
      CALL DESTROY_PLAN_FFT(TC%FFTC_PLANS(KN)%NPLAN)
      TC%FFTC_PLANS(KN)%NPLAN_ID=999999
      START_FFTC_PLAN=>TC%FFTC_PLANS(KN)
      TC%FFTC_PLANS(KN)=TC%FFTC_PLANS(KN)%NEXT_PLAN
      ! DEALLOCATE(START_FFTC_PLAN)
      TC%N_PLANS(KN)=TC%N_PLANS(KN)-1
!     WRITE(*,'("CREATE_PLAN_FFT: END: DESTROYING A PLAN AT THE START OF THE LIST")')
    ENDIF
  ENDIF
  CALL CREATE_PLAN_FFTC(IPLAN,KTYPE,KN,KLOT,KSTRIDE)
  KPLAN=IPLAN
  TC%N_PLANS(KN)=TC%N_PLANS(KN)+1
  IF( TC%N_PLANS(KN) /= 1 )THEN
    ALLOCATE(CURR_FFTC_PLAN%NEXT_PLAN)
    CURR_FFTC_PLAN=>CURR_FFTC_PLAN%NEXT_PLAN
  ENDIF
  IF( CURR_FFTC_PLAN%NPLAN_ID /= 123456 )THEN
    WRITE(*,'("CREATE_PLAN_FFT.4: PLAN_ID=",I10)')CURR_FFTC_PLAN%NPLAN_ID
    CALL ABOR1('CREATE_PLAN_FFT.4: NPLAN_ID /= 123456')
  ENDIF
  CURR_FFTC_PLAN%NPLAN=IPLAN
  CURR_FFTC_PLAN%NLOT=KLOT
  CURR_FFTC_PLAN%NSTRIDE=KSTRIDE
  CURR_FFTC_PLAN%NTYPE=KTYPE
  CURR_FFTC_PLAN%NEXT_PLAN=>NULL()
! write(*,'("CREATE_PLAN_FFT: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
!  & " NEW IPLAN=",Z16)')KN,TC%N_PLANS(KN),KLOT,KTYPE,IPLAN
ELSE
  KPLAN=IPLAN
! write(*,'("CREATE_PLAN_FFT: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
!  & " CUR IPLAN=",Z16)')KN,TC%N_PLANS(KN),KLOT,KTYPE,IPLAN
ENDIF
!!$OMP END CRITICAL

RETURN
END SUBROUTINE CREATE_PLAN_FFT


SUBROUTINE DESTROY_PLAN_FFT(KPLAN)
INTEGER(KIND=JPIM),INTENT(IN) :: KPLAN
CALL DESTROY_PLAN_FFTC(KPLAN)
RETURN
END SUBROUTINE DESTROY_PLAN_FFT


SUBROUTINE DESTROY_ALL_PLANS_FFT
INTEGER(KIND=JPIM) :: JL, JN
TYPE(FFTC_PLAN),POINTER :: CURR_FFTC_PLAN
DO JN=1,TC%N_MAX
  CURR_FFTC_PLAN=>TC%FFTC_PLANS(JN)
ENDDO
WRITE(*,'("DESTROY_ALL_PLANS_FFTC: MPL_RANK=",I6," SUM(TC%N_PLANS(:))=",I10)')&
  & MPL_MYRANK(), SUM(TC%N_PLANS(:))
DEALLOCATE(TC%FFTC_PLANS)
DEALLOCATE(TC%N_PLANS)
RETURN
END SUBROUTINE DESTROY_ALL_PLANS_FFT


END MODULE TPM_FFTC
