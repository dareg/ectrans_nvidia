#define ALIGN(I, A) (((I)+(A)-1)/(A)*(A))
! (C) Copyright 2000- ECMWF.
! (C) Copyright 2022- NVIDIA.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE LEDIR_MOD
  USE PARKIND_ECTRANS  ,ONLY : JPIM

  PRIVATE
  PUBLIC :: LEDIR, LEDIR_ALLOC_SIZE

  INTEGER(KIND=JPIM) :: A = 8 !Alignment
CONTAINS
FUNCTION LEDIR_ALLOC_SIZE(KF_FS)
  USE PARKIND_ECTRANS  ,ONLY : JPIM, JPRBT, JPRD
  USE TPM_DIM         ,ONLY : R
  USE TPM_DISTR       ,ONLY : D

  IMPLICIT NONE

  INTEGER(KIND=JPIM), INTENT(IN)  :: KF_FS

  INTEGER(KIND=JPIM)  :: IOUT_STRIDES0, IOUT_STRIDES1
  INTEGER(KIND=JPIM)  :: IIN_STRIDES0, IIN_STRIDES1
  INTEGER(KIND=JPIM)  :: IOUT0_STRIDES0, IOUT0_STRIDES1
  INTEGER(KIND=JPIM)  :: IIN0_STRIDES0, IIN0_STRIDES1
  INTEGER(KIND=8)  :: LEDIR_ALLOC_SIZE

  REAL(KIND=JPRBT) :: ZPRBT_DUMMY
  REAL(KIND=JPRD) :: ZPRD_DUMMY

  IOUT_STRIDES0 = ALIGN(2*KF_FS,A)
  IOUT_STRIDES1 = IOUT_STRIDES0 * ALIGN(MAX((R%NTMAX+2)/2,(R%NTMAX+3)/2),A)
  IIN_STRIDES0 = ALIGN(2*KF_FS,A)
  IIN_STRIDES1 = IIN_STRIDES0 * ALIGN(R%NDGNH,A)
  IOUT0_STRIDES0 = ALIGN(KF_FS,A)
  IOUT0_STRIDES1 = IOUT0_STRIDES0 * ALIGN(MAX((R%NTMAX+2)/2,(R%NTMAX+3)/2),A)
  IIN0_STRIDES0 = ALIGN(KF_FS,A)
  IIN0_STRIDES1 = IIN0_STRIDES0 * ALIGN(R%NDGNH,A)

  ! Check if the reuse buffer is large enough
  LEDIR_ALLOC_SIZE = ALIGN(IIN_STRIDES1*D%NUMP,8)*SIZEOF(ZPRBT_DUMMY) &
      +ALIGN(IIN_STRIDES1*D%NUMP,8)*SIZEOF(ZPRBT_DUMMY) &
      +ALIGN(IOUT_STRIDES1*D%NUMP,8)*SIZEOF(ZPRBT_DUMMY) &
      +ALIGN(IIN0_STRIDES1,8)*SIZEOF(ZPRD_DUMMY) &
      +ALIGN(IIN0_STRIDES1,8)*SIZEOF(ZPRD_DUMMY) &
      +ALIGN(IOUT0_STRIDES1,8)*SIZEOF(ZPRD_DUMMY)
END FUNCTION
SUBROUTINE LEDIR(FOUBUF,POA1,KF_FS,KF_UV)

!**** *LEDIR* - Direct Legendre transform.

!     Purpose.
!     --------
!        Direct Legendre tranform of state variables.

!**   Interface.
!     ----------
!        CALL LEDIR(...)

!        Explicit arguments :  KM - zonal wavenumber
!        --------------------  KFC - number of field to transform
!                              fields for zonal wavenumber KM
!                              PSIA - symmetric part of Fourier
!                              fields for zonal wavenumber KM
!                              POA1 -  spectral
!                              fields for zonal wavenumber KM

!        Implicit arguments :  None.
!        --------------------

!     Method.
!     -------   use butterfly or dgemm

!     Externals.   
!     ----------

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!          Nils Wedi + Mats Hamrud + George Modzynski

!     Modifications.
!     --------------
!        J.Hague : Oct 2012 DR_HOOK round calls to DGEMM:
!      F. Vana  05-Mar-2015  Support for single precision
!     ------------------------------------------------------------------

USE TPM_GEN         ,ONLY : LSYNC_TRANS
USE PARKIND_ECTRANS  ,ONLY : JPIM, JPRBT, JPRD
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK, JPHOOK
USE TPM_DIM         ,ONLY : R, R_NDGNH,R_NSMAX,R_NTMAX,R_NDGL
USE TPM_GEOMETRY    ,ONLY : G, G_NDGLU
USE TPM_FIELDS      ,ONLY : F,ZAA,ZAS,ZAA0,ZAS0,KMLOC0
USE TPM_TRANS, ONLY: REUSE_PTR
USE TPM_DISTR       ,ONLY : D,D_NUMP,D_MYMS, D_NPNTGTB1
USE CUDA_GEMM_BATCHED_MOD
USE MPL_MODULE      ,ONLY : MPL_BARRIER
USE TPM_STATS, ONLY : GSTATS => GSTATS_NVTX
USE, INTRINSIC :: ISO_C_BINDING
USE IEEE_ARITHMETIC
USE OPENACC

!!!!
USE TPM_DISTR       ,ONLY : D,MYSETW,MYPROC, NPROC, D_NSTAGTF, D_NPNTGTB0,D_NPTRLS
USE TPM_GEOMETRY    ,ONLY : G,G_NMEN,G_NLOEN


IMPLICIT NONE


!     DUMMY ARGUMENTS
REAL(KIND=JPRBT), ALLOCATABLE, INTENT(INOUT) :: FOUBUF(:)
REAL(KIND=JPRBT),  INTENT(OUT) :: POA1(:,:,:)
INTEGER(KIND=JPIM), INTENT(IN)  :: KF_FS, KF_UV

!     LOCAL VARIABLES
INTEGER(KIND=JPIM)  :: KM
INTEGER(KIND=JPIM)  :: KMLOC
INTEGER(KIND=JPIM) :: IA, IS, ISL, J
INTEGER(KIND=JPIM)  :: KS(D_NUMP), NS(D_NUMP), AOFFSETS(D_NUMP), BOFFSETS(D_NUMP), COFFSETS(D_NUMP)
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
REAL(KIND=JPRBT) :: PAIA, PAIS, V1, V2

INTEGER(KIND=JPIM) :: IGLS,  JF, JGL
INTEGER(KIND=JPIM) :: OFFSET1, OFFSET2
REAL(KIND=JPRBT), POINTER :: ZBASE(:), ZINPS(:), ZINPA(:), ZOUT(:)
REAL(KIND=JPRD), POINTER :: ZBASE0(:), ZINPS0(:), ZINPA0(:), ZOUT0(:)

INTEGER(KIND=JPIM)  :: IOUT_STRIDES0, IOUT_STRIDES1
INTEGER(KIND=JPIM)  :: IIN_STRIDES0, IIN_STRIDES1
INTEGER(KIND=JPIM)  :: IOUT0_STRIDES0, IOUT0_STRIDES1
INTEGER(KIND=JPIM)  :: IIN0_STRIDES0, IIN0_STRIDES1
INTEGER(KIND=8)  :: ALLOC_SZ, ALLOC_POS

  INTEGER(KIND=JPIM) :: IGLG, IOFF_LAT, ISTA, OFFSET_VAR, KGL, JM
  REAL(KIND=JPRBT):: SCAL
  REAL(KIND=JPRBT), POINTER :: PREEL_COMPLEX(:)

IF (LHOOK) CALL DR_HOOK('LE_DGEMM',0,ZHOOK_HANDLE)

IOUT_STRIDES0 = ALIGN(2*KF_FS,A)
IOUT_STRIDES1 = IOUT_STRIDES0 * ALIGN(MAX((R%NTMAX+2)/2,(R%NTMAX+3)/2),A)
IIN_STRIDES0 = ALIGN(2*KF_FS,A)
IIN_STRIDES1 = IIN_STRIDES0 * ALIGN(R_NDGNH,A)
IOUT0_STRIDES0 = ALIGN(KF_FS,A)
IOUT0_STRIDES1 = IOUT0_STRIDES0 * ALIGN(MAX((R%NTMAX+2)/2,(R%NTMAX+3)/2),A)
IIN0_STRIDES0 = ALIGN(KF_FS,A)
IIN0_STRIDES1 = IIN0_STRIDES0 * ALIGN(R_NDGNH,A)

IF (NPROC == 1) THEN
  ! Short cut - no need to go through tansforms, we will go directly into
  ! the legendre space, but for that we need twice the memory, roughly
  ! (but we don't need the send/recv buffers)
  ALLOC_SZ = KF_FS*D%NLENGTF*SIZEOF(REUSE_PTR(1))
ELSE
  ALLOC_SZ = 0
ENDIF

! Check if the reuse buffer is large enough
ALLOC_SZ = ALLOC_SZ &
    +ALIGN(IIN_STRIDES1*D_NUMP,8)*SIZEOF(ZINPS(1)) &
    +ALIGN(IIN_STRIDES1*D_NUMP,8)*SIZEOF(ZINPA(1)) &
    +ALIGN(IOUT_STRIDES1*D_NUMP,8)*SIZEOF(ZOUT(1)) &
    +ALIGN(IIN0_STRIDES1,8)*SIZEOF(ZINPS0(1)) &
    +ALIGN(IIN0_STRIDES1,8)*SIZEOF(ZINPA0(1)) &
    +ALIGN(IOUT0_STRIDES1,8)*SIZEOF(ZOUT0(1))

IF (.NOT. ALLOCATED(REUSE_PTR)) THEN
  ALLOCATE(REUSE_PTR(ALLOC_SZ/SIZEOF(REUSE_PTR(1))))
  !$ACC ENTER DATA CREATE(REUSE_PTR)
ELSEIF (SIZEOF(REUSE_PTR) < ALLOC_SZ) THEN
  ! and reallocate if needed
  !$ACC EXIT DATA DELETE(REUSE_PTR)
  DEALLOCATE(REUSE_PTR)
  ALLOCATE(REUSE_PTR(ALLOC_SZ/SIZEOF(REUSE_PTR(1))))
  !$ACC ENTER DATA CREATE(REUSE_PTR)
ENDIF

! Figure out which pointers to use
ALLOC_POS=1
IF (NPROC == 1) THEN
  ALLOC_POS = ALLOC_POS+KF_FS*D%NLENGTF
ENDIF
CALL C_F_POINTER(C_LOC(REUSE_PTR(ALLOC_POS:)), ZBASE, &
    & [SIZEOF(REUSE_PTR(ALLOC_POS:))/SIZEOF(ZBASE(0))])

ALLOC_POS=1
ZINPS(1:) => ZBASE(ALLOC_POS:ALLOC_POS+IIN_STRIDES1*D_NUMP-1)
ALLOC_POS=ALLOC_POS+ALIGN(IIN_STRIDES1*D_NUMP,8)
ZINPA(1:) => ZBASE(ALLOC_POS:ALLOC_POS+IIN_STRIDES1*D_NUMP-1)
ALLOC_POS=ALLOC_POS+ALIGN(IIN_STRIDES1*D_NUMP,8)
ZOUT(1:) => ZBASE(ALLOC_POS:ALLOC_POS+IOUT_STRIDES1*D_NUMP-1)
ALLOC_POS=ALLOC_POS+ALIGN(IOUT_STRIDES1*D_NUMP,8)

! The BASE0 pointer points to the rest, but likely in a different type!
CALL C_F_POINTER(C_LOC(ZBASE(ALLOC_POS:)), ZBASE0, &
    & [SIZEOF(ZBASE(ALLOC_POS:))/SIZEOF(ZBASE0(0))])
ALLOC_POS=1
ZINPS0(1:) => ZBASE0(ALLOC_POS:ALLOC_POS+IIN0_STRIDES1-1)
ALLOC_POS=ALLOC_POS+ALIGN(IIN0_STRIDES1,8)
ZINPA0(1:) => ZBASE0(ALLOC_POS:ALLOC_POS+IIN0_STRIDES1-1)
ALLOC_POS=ALLOC_POS+ALIGN(IIN0_STRIDES1,8)
ZOUT0(1:) => ZBASE0(ALLOC_POS:ALLOC_POS+IOUT0_STRIDES1-1)
ALLOC_POS=ALLOC_POS+ALIGN(IOUT0_STRIDES1,8)

!$ACC DATA &
!$ACC& PRESENT(ZINPS,ZINPA,ZOUT,ZINPS0,ZINPA0,ZOUT0) &
!$ACC& PRESENT(F,F%RW) &
!$ACC& PRESENT(D,D_MYMS,R,G,G_NDGLU) &
!$ACC& PRESENT(ZAA,ZAS,POA1) &
!$ACC& PRESENT(D_NPNTGTB1)

IF (NPROC > 1) THEN

  !$ACC DATA PRESENT(FOUBUF)
  !$ACC PARALLEL LOOP DEFAULT(NONE) COLLAPSE(3) PRIVATE(KM,ISL,IGLS,OFFSET1,OFFSET2,JGL,PAIA,PAIS) ASYNC(1)
  DO KMLOC=1,D_NUMP
    DO JGL=1,R_NDGNH
      DO JF=1,KF_FS*2
        KM = D_MYMS(KMLOC)
        ISL = R_NDGNH-G_NDGLU(KM)+1
        IF (JGL >= ISL) THEN
          !(DO JGL=ISL,R_NDGNH)
          IGLS = R_NDGL+1-JGL
          OFFSET1 = D_NPNTGTB1(KMLOC,JGL )*2*KF_FS
          OFFSET2 = D_NPNTGTB1(KMLOC,IGLS)*2*KF_FS
          PAIA = FOUBUF(OFFSET1+JF)-FOUBUF(OFFSET2+JF)
          PAIS = FOUBUF(OFFSET1+JF)+FOUBUF(OFFSET2+JF)
          IF (JF <= 4*KF_UV) THEN
              ! Multiply in case of velocity
            PAIA = PAIA*F%RACTHE(JGL)
            PAIS = PAIS*F%RACTHE(JGL)
          ENDIF
          IF (KM /= 0) THEN
            ZINPA(JF+(JGL-ISL)*IIN_STRIDES0+(KMLOC-1)*IIN_STRIDES1)=PAIA*F%RW(JGL)
            ZINPS(JF+(JGL-ISL)*IIN_STRIDES0+(KMLOC-1)*IIN_STRIDES1)=PAIS*F%RW(JGL)
          ELSEIF (MOD(JF-1,2) == 0) THEN
            ! every other field is sufficient because Im(KM=0) == 0
            ZINPA0((JF-1)/2+1+(JGL-1)*IIN0_STRIDES0)=PAIA*F%RW(JGL)
            ZINPS0((JF-1)/2+1+(JGL-1)*IIN0_STRIDES0)=PAIS*F%RW(JGL)
          ENDIF
        ENDIF
      ENDDO
    ENDDO
  END DO
  !$ACC END DATA
ELSE

  OFFSET_VAR=D_NPTRLS(MYSETW)

  PREEL_COMPLEX(1:) => REUSE_PTR(1:)
  !$ACC DATA PRESENT(PREEL_COMPLEX,D_NSTAGTF,G_NLOEN)
  !$ACC PARALLEL LOOP DEFAULT(NONE) PRIVATE(KM,ISL,IGLS,OFFSET1,OFFSET2,JGL,PAIA,PAIS,IGLS,V1,V2,SCAL,IGLG) ASYNC(1) TILE(32,16,1)
  DO JGL=1,R_NDGNH
    DO KMLOC=1,D_NUMP
      DO JF=1,KF_FS*2
        KM = D_MYMS(KMLOC)
        ISL = R_NDGNH-G_NDGLU(KM)+1
        IF (JGL >= ISL) THEN
          !(DO JGL=ISL,R_NDGNH)
          IGLS = JGL

          OFFSET1 = KF_FS*D_NSTAGTF(IGLS)+(JF-1)/2*(D_NSTAGTF(IGLS+1)-D_NSTAGTF(IGLS))
          IGLG = OFFSET_VAR+IGLS-1
          SCAL = 1._JPRBT/REAL(G_NLOEN(IGLG),JPRBT)
          V1 = SCAL * PREEL_COMPLEX(OFFSET1+2*(KMLOC-1)+1+MOD(JF-1,2))

          IGLS = R_NDGL+1-JGL
          OFFSET2 = KF_FS*D_NSTAGTF(IGLS)+(JF-1)/2*(D_NSTAGTF(IGLS+1)-D_NSTAGTF(IGLS))
          IGLG = OFFSET_VAR+IGLS-1
          SCAL = 1._JPRBT/REAL(G_NLOEN(IGLG),JPRBT)
          V2 = SCAL * PREEL_COMPLEX(OFFSET2+2*(KMLOC-1)+1+MOD(JF-1,2))

          PAIA = V1-V2
          PAIS = V1+V2
          IF (JF <= 4*KF_UV) THEN
              ! Multiply in case of velocity
            PAIA = PAIA*F%RACTHE(JGL)
            PAIS = PAIS*F%RACTHE(JGL)
          ENDIF
          IF (KM /= 0) THEN
            ZINPA(JF+(JGL-ISL)*IIN_STRIDES0+(KMLOC-1)*IIN_STRIDES1)=PAIA*F%RW(JGL)
            ZINPS(JF+(JGL-ISL)*IIN_STRIDES0+(KMLOC-1)*IIN_STRIDES1)=PAIS*F%RW(JGL)
          ELSEIF (MOD(JF-1,2) == 0) THEN
            ! every other field is sufficient because Im(KM=0) == 0
            ZINPA0((JF-1)/2+1+(JGL-1)*IIN0_STRIDES0)=PAIA*F%RW(JGL)
            ZINPS0((JF-1)/2+1+(JGL-1)*IIN0_STRIDES0)=PAIS*F%RW(JGL)
          ENDIF
        ENDIF
      ENDDO
    ENDDO
  END DO
  !$ACC END DATA
ENDIF

! anti-symmetric
IF(KMLOC0 > 0) THEN
  PRINT*,'computing m=0 in double precision'
ENDIF

IF (LSYNC_TRANS) THEN
  !$ACC WAIT(1)
  CALL GSTATS(430,0)
  CALL MPL_BARRIER(CDSTRING='')
  CALL GSTATS(430,1)
ENDIF
CALL GSTATS(414,0)

IF(KMLOC0 > 0) THEN
  ! compute m=0 in double precision:
  CALL CUDA_GEMM_BATCHED( &
    & CUBLAS_OP_N, CUBLAS_OP_N, &
    & KF_FS, (R%NSMAX+2)/2, G%NDGLU(0), &
    & 1.0_JPRD, &
    & ZINPA0, IIN0_STRIDES0, 0, &
    & ZAA0, SIZE(ZAA0,1), 0, &
    & 0.0_JPRD, &
    & ZOUT0, IOUT0_STRIDES0, 0, &
    & 1, STREAM=1_C_LONG)
ENDIF
! Get C in transpose format to get better memory access patterns later
!C=A*B =>
! C^T=B^T*A^T
DO KMLOC=1,D_NUMP
  KM = D_MYMS(KMLOC)
  NS(KMLOC) = (R%NSMAX-KM+2)/2
  KS(KMLOC) = G%NDGLU(KM)
  AOFFSETS(KMLOC) = IIN_STRIDES1*(KMLOC-1)
  BOFFSETS(KMLOC) = SIZE(ZAA,1)*SIZE(ZAA,2)*(KMLOC-1)
  COFFSETS(KMLOC) = IOUT_STRIDES1*(KMLOC-1)
ENDDO
IF(KMLOC0 > 0) THEN
  NS(KMLOC0) = 0
  KS(KMLOC0) = 0
ENDIF
CALL CUDA_GEMM_BATCHED( &
  & 21, & ! unique identifier
  & CUBLAS_OP_N, CUBLAS_OP_N, &
  & 2*KF_FS, NS(:), KS(:), &
  & 1.0_JPRBT, &
  & ZINPA, IIN_STRIDES0, AOFFSETS, &
  & ZAA, SIZE(ZAA,1), BOFFSETS, &
  & 0.0_JPRBT, &
  & ZOUT, IOUT_STRIDES0, COFFSETS, &
  & D_NUMP, STREAM=1_C_LONG)
IF (LSYNC_TRANS) THEN
  !$ACC WAIT(1)
  CALL GSTATS(434,0)
  CALL MPL_BARRIER(CDSTRING='')
  CALL GSTATS(434,1)
ENDIF
CALL GSTATS(414,1)

!$ACC PARALLEL LOOP COLLAPSE(2) PRIVATE(KM,IA,J) DEFAULT(NONE) ASYNC(1)
DO KMLOC=1,D_NUMP
  DO JF=1,2*KF_FS
    KM = D_MYMS(KMLOC)
    IA  = 1+MOD(R_NTMAX-KM+2,2)
    IF (KM /= 0) THEN
      !$ACC LOOP SEQ
      DO J=1,(R%NSMAX-KM+2)/2
        POA1(JF,IA+1+(J-1)*2,KMLOC) = ZOUT(JF+(J-1)*IOUT_STRIDES0+(KMLOC-1)*IOUT_STRIDES1)
      ENDDO
    ELSEIF (MOD(JF-1,2) == 0) THEN
      !$ACC LOOP SEQ
      DO J=1,(R_NSMAX+2)/2
        POA1(JF,IA+1+(J-1)*2,KMLOC) = ZOUT0((JF-1)/2+1+(J-1)*IOUT0_STRIDES0)
      ENDDO
    ENDIF
  ENDDO
ENDDO

! symmetric

IF (LSYNC_TRANS) THEN
  !$ACC WAIT(1)
  CALL GSTATS(430,0)
  CALL MPL_BARRIER(CDSTRING='')
  CALL GSTATS(430,1)
ENDIF
CALL GSTATS(414,0)

IF(KMLOC0 > 0) THEN
  ! compute m=0 in double precision:
  call CUDA_GEMM_BATCHED( &
    & CUBLAS_OP_N, CUBLAS_OP_N, &
    & KF_FS, (R%NSMAX+3)/2, G%NDGLU(0), &
    & 1.0_JPRD, &
    & ZINPS0, IIN0_STRIDES0, 0, &
    & ZAS0, SIZE(ZAS0,1), 0, &
    & 0.0_JPRD, &
    & ZOUT0, IOUT0_STRIDES0, 0, &
    & 1, STREAM=1_C_LONG)
ENDIF

! Get C in transpose format to get better memory access patterns later
!C=A*B =>
! C^T=B^T*A^T
DO KMLOC=1,D_NUMP
  KM = D_MYMS(KMLOC)
  NS(KMLOC) = (R%NSMAX-KM+3)/2
  KS(KMLOC) = G%NDGLU(KM)
  AOFFSETS(KMLOC) = IIN_STRIDES1*(KMLOC-1)
  BOFFSETS(KMLOC) = SIZE(ZAS,1)*SIZE(ZAS,2)*(KMLOC-1)
  COFFSETS(KMLOC) = IOUT_STRIDES1*(KMLOC-1)
ENDDO
IF(KMLOC0 > 0) THEN
  NS(KMLOC0) = 0
  KS(KMLOC0) = 0
ENDIF
CALL CUDA_GEMM_BATCHED( &
  & 22, & ! unique identifier
  & CUBLAS_OP_N, CUBLAS_OP_N, &
  & 2*KF_FS, NS(:), KS(:), &
  & 1.0_JPRBT, &
  & ZINPS, IIN_STRIDES0, AOFFSETS, &
  & ZAS, SIZE(ZAS,1), BOFFSETS, &
  & 0.0_JPRBT, &
  & ZOUT, IOUT_STRIDES0, COFFSETS, &
  & D_NUMP, STREAM=1_C_LONG)
IF (LSYNC_TRANS) THEN
  !$ACC WAIT(1)
  CALL GSTATS(434,0)
  CALL MPL_BARRIER(CDSTRING='')
  CALL GSTATS(434,1)
ENDIF
CALL GSTATS(414,1)

!$ACC PARALLEL LOOP COLLAPSE(2) PRIVATE(KM,IS) DEFAULT(NONE) ASYNC(1)
DO KMLOC=1,D_NUMP
  DO JF=1,2*KF_FS
    KM = D_MYMS(KMLOC)
    IS  = 1+MOD(R_NTMAX-KM+1,2)
    IF (KM /= 0) THEN
      !$ACC LOOP SEQ
      DO J=1,(R_NSMAX-KM+3)/2
        POA1(JF,IS+1+(J-1)*2,KMLOC) = ZOUT(JF+(J-1)*IOUT_STRIDES0+(KMLOC-1)*IOUT_STRIDES1)
      ENDDO
    ELSEIF (MOD(JF-1,2) == 0) THEN
      !$ACC LOOP SEQ
      DO J=1,(R_NSMAX+3)/2
        POA1(JF,IS+1+(J-1)*2,KMLOC) = ZOUT0((JF-1)/2+1+(J-1)*IOUT0_STRIDES0)
      ENDDO
    ENDIF
  ENDDO
ENDDO
!$ACC WAIT(1)

!$ACC END DATA

IF (NPROC > 1) THEN
  !$ACC EXIT DATA DELETE(FOUBUF)
  DEALLOCATE(FOUBUF)
ENDIF


IF (LHOOK) CALL DR_HOOK('LE_DGEMM',1,ZHOOK_HANDLE)
!     ------------------------------------------------------------------

END SUBROUTINE LEDIR
END MODULE LEDIR_MOD
