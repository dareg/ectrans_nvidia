! (C) Copyright 2014- ECMWF.
! (C) Copyright 2022- NVIDIA.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

PROGRAM TRANSFORM_TEST

!
! Spectral transform test
!
! This test performs spectral to real and real to spectral transforms repeated in
! timed loop.
!
! 
! Author : George Mozdzynski
!

USE PARKIND1  ,ONLY  : JPIM     ,JPRB, JPRD
USE OML_MOD ,ONLY : OML_MAX_THREADS
USE MPL_MPIF
USE MPL_MODULE
USE GRIB_API
USE YOMGSTATS, ONLY: JPMAXSTAT, YLSTATS => LSTATS

IMPLICIT NONE

INTEGER(KIND=JPIM) :: RETURN_CODE

CHARACTER CTYPEG*1
CHARACTER*127 CINSF, CRTABLE
CHARACTER*127 CGRIDTYPE,CFNAME

! Maximum latitudes, currently equal to TCO7999
INTEGER(KIND=JPIM),PARAMETER :: JPMLAT=16000

INTEGER(KIND=JPIM) :: ISTACK, GETSTACKUSAGE
REAL(KIND=JPRB), DIMENSION(1)  :: ZMAXERR(5), ZERR(5)
REAL(KIND=JPRB) :: ZMAXERRG

INTEGER(KIND=JPIM) :: NRGRI(JPMLAT)
INTEGER(KIND=JPIM) :: NERR,NULNAM,NLIN,INSF,NSMAX,NDGL,NQ
INTEGER(KIND=JPIM) :: ITABLE,NOUT,NOUTDUMP,NSPEC2,NGPTOT,NGPTOTG,IFLD,IFLDS,ICODE,IOUTSF,JROC,JB
INTEGER(KIND=JPIM) :: IERR,ITAG,NSPEC2G,IRET,NTYPE,I,IGRIBOUT,IMAX_FLDS_IN
INTEGER(KIND=JPIM) :: JF,JA,IB,JPRTRV
INTEGER(KIND=JPIM), DIMENSION(1) :: IPARAM,IGRIB,IEDITION,ICURLEV
INTEGER(KIND=JPIM) ,ALLOCATABLE :: NLOEN(:),ITO(:),NPRCIDS(:)
INTEGER(KIND=JPIM) :: MYPROC,JJ
INTEGER   :: JSTEP
REAL(KIND=JPRD)    :: ZTINIT,ZTLOOP,TIMEF, ZTSTEPMAX, ZTSTEPMIN, ZTSTEPAVG, ZTSTEPMED
REAL(KIND=JPRD)    :: ZTSTEPMAX1, ZTSTEPMIN1, ZTSTEPAVG1, ZTSTEPMED1
REAL(KIND=JPRD)    :: ZTSTEPMAX2, ZTSTEPMIN2, ZTSTEPAVG2, ZTSTEPMED2
REAL(KIND=JPRD),ALLOCATABLE :: ZTSTEP(:), ZTSTEP1(:), ZTSTEP2(:)
REAL(KIND=JPRB),ALLOCATABLE :: ZFPDAT(:)
REAL(KIND=JPRB),ALLOCATABLE :: ZNORMSP(:),ZNORMSP1(:),ZNORMDIV(:),ZNORMDIV1(:)
REAL(KIND=JPRB),ALLOCATABLE :: ZNORMVOR(:),ZNORMVOR1(:),ZNORMT(:),ZNORMT1(:)
REAL(KIND=JPRB),ALLOCATABLE :: ZNORM(:),ZNORM1(:)
REAL(KIND=JPRD) :: ZAVEAVE(0:JPMAXSTAT)

! GRID-POINT SPACE DATA STRUCTURES
REAL(KIND=JPRB), ALLOCATABLE :: ZWINDS (:,:,:,:) ! Multilevel fields at t and t-dt
REAL(KIND=JPRB), ALLOCATABLE, TARGET :: ZGMV   (:,:,:,:) ! Multilevel fields at t and t-dt
REAL(KIND=JPRB), ALLOCATABLE, TARGET :: ZGMVS  (:,:,:)   ! Single level fields at t and t-dt

! SPECTRAL SPACE DATA STRUCTURES
REAL(KIND=JPRB), ALLOCATABLE :: ZSPVORG(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPDIVG(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPSPG(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPTG(:,:,:)
REAL(KIND=JPRB), ALLOCATABLE, TARGET :: SP3D(:,:,:)
REAL(KIND=JPRB), POINTER :: ZVOR(:,:) => NULL()
REAL(KIND=JPRB), POINTER :: ZDIV(:,:) => NULL()
REAL(KIND=JPRB), POINTER :: ZT(:,:,:) => NULL()
REAL(KIND=JPRB), ALLOCATABLE :: ZSP(:,:)

REAL(KIND=JPRB),ALLOCATABLE :: PAVE(:)
REAL(KIND=JPRB),ALLOCATABLE :: PMIN(:)
REAL(KIND=JPRB),ALLOCATABLE :: PMAX(:)

LOGICAL :: LSTACK
LOGICAL :: LDONE,LSTDEV
LOGICAL :: LUSERPNM, LKEEPRPNM, LUSEFLT
LOGICAL :: LTRACE_STATS,LSTATS_OMP, LSTATS_COMMS, LSTATS_MPL
LOGICAL :: LSTATS,LBARRIER_STATS, LBARRIER_STATS2, LDETAILED_STATS
LOGICAL :: LSTATS_ALLOC, LSYNCSTATS, LSTATSCPU, LSTATS_MEM
LOGICAL :: LXML_STATS, LDUMP
LOGICAL :: LFFTW
INTEGER(KIND=JPIM) :: NSTATS_MEM, NTRACE_STATS, NPRNT_STATS
! 0 - no output, 1 - init and final result, 2 - every timestep
INTEGER(KIND=JPIM) :: NPRINTNORMS=0
LOGICAL :: LMPOFF
INTEGER(KIND=JPIM) :: ITERS=100

REAL(KIND=JPRB) :: ZMAXERR_CHECK=0.0_JPRB
REAL(KIND=JPRB) :: ZRA=6371229._JPRB

INTEGER(KIND=JPIM) :: NMAX_RESOL
INTEGER(KIND=JPIM) :: NPRINTLEV
INTEGER(KIND=JPIM) :: NPROMATR
INTEGER(KIND=JPIM) :: NCOMBFLEN

INTEGER(KIND=JPIM) :: NPROC
INTEGER(KIND=JPIM) :: NTHREAD
INTEGER(KIND=JPIM) :: NPRGPNS
INTEGER(KIND=JPIM) :: NPRGPEW
INTEGER(KIND=JPIM) :: NPRTRV
INTEGER(KIND=JPIM) :: NPRTRW
INTEGER(KIND=JPIM) :: NSPECRESMIN
INTEGER(KIND=JPIM) :: MYSETV
INTEGER(KIND=JPIM) :: MYSETW
INTEGER(KIND=JPIM) :: MYSETA
INTEGER(KIND=JPIM) :: MYSETB
INTEGER(KIND=JPIM) :: MP_TYPE
INTEGER(KIND=JPIM) :: MBX_SIZE

INTEGER(KIND=JPIM), ALLOCATABLE :: NUMLL(:), IVSET(:), NPSURF(:)
INTEGER(KIND=JPIM) :: IVSETSC(1)
INTEGER(KIND=JPIM) :: NPSP ! Set to 1 if PE has V set with surface variables

INTEGER(KIND=JPIM) :: NFLEVG, NFLEVL
! SUMPINI
INTEGER(KIND=JPIM) :: ISQR
LOGICAL :: LSYNC_TRANS
LOGICAL :: LEQ_REGIONS


INTEGER(KIND=JPIM) :: NPROMA
INTEGER(KIND=JPIM) :: NGPBLKS
! LOCALS
INTEGER(KIND=JPIM) :: IPRTRV
INTEGER(KIND=JPIM) :: IPRTRW
INTEGER(KIND=JPIM) :: IPRUSED, ILEVPP, IREST, ILEV, JLEV, ILASTLEV

LOGICAL :: LLINFO

INTEGER(KIND=JPIM) :: NDIMGMV ! Third dim. of GMV "(NPROMA,NFLEVG,NDIMGMV,NGPBLKS)"
INTEGER(KIND=JPIM) :: NDIMGMVS ! Second dim. GMVS "(NPROMA,NDIMGMVS,NGPBLKS)"

NAMELIST/NAMRGRI/ NRGRI
NAMELIST/NAMTRANS/ LSTATS, LBARRIER_STATS, LBARRIER_STATS2, LDETAILED_STATS, &
                 & LUSERPNM, LKEEPRPNM, LUSEFLT, NQ, NLIN, IMAX_FLDS_IN, &
                 & NPRINTNORMS, ITERS, ZMAXERR_CHECK, NPROMA, NPROMATR, LEQ_REGIONS, &
                 & NPRINTLEV, NPRTRW, NPRTRV, NSPECRESMIN, NFLEVG, MBX_SIZE, LSTACK, &
                 & LFFTW, LDUMP

!     ------------------------------------------------------------------

#include "setup_trans0.h"
#include "setup_trans.h"
#include "inv_trans.h"
#include "dir_trans.h"
#include "gpnorm_trans.h"
#include "dist_spec.h"
#include "gath_grid.h"
#include "trans_inq.h"
#include "specnorm.h"
#include "abor1.intfb.h"
#include "gstats_setup.intfb.h"

! Default initializations
NERR = 0
NULNAM = 4
NOUT = 6
! Unit number for file to dump 2D fields to
NOUTDUMP = 7
! Max number of resolutions
NMAX_RESOL=37
! Print level
NPRINTLEV=0
! NPROMA for trans lib
NPROMATR=0
! Size of comm buffer
NCOMBFLEN=1800000
! EQ REGIONS flag
LEQ_REGIONS=.TRUE.
! Message Passing switch
LMPOFF=.FALSE.
! Activate barrier sync
LSYNC_TRANS=.true.
! Number of procs
NPROC=0
! Grid-point decomp
NPRGPNS=0
NPRGPEW=0
! Spectral decomp
NPRTRW=0
NPRTRV=0
! Minimum spectral resolution
! Used for controlling NPRTRW
NSPECRESMIN=0
! Message passing type
MP_TYPE=2
! Mailbox size
MBX_SIZE=150000000
! GSTATS statistics 
LSTATS=.FALSE.
LDETAILED_STATS=.FALSE.
LSTATS_OMP=.FALSE.
LSTATS_COMMS=.FALSE.
LSTATS_MPL=.FALSE.
LBARRIER_STATS=.FALSE.
LBARRIER_STATS2=.FALSE.
LSTATSCPU=.FALSE.
LSYNCSTATS=.FALSE.
LDUMP=.TRUE.
LXML_STATS=.FALSE.
LTRACE_STATS=.FALSE.
NSTATS_MEM=0
LSTATS_MEM=.FALSE.
LSTATS_ALLOC=.FALSE.
NTRACE_STATS=0
NPRNT_STATS=1
LUSERPNM=.FALSE.
LKEEPRPNM=.FALSE.
! Use fast Legendre transforms
LUSEFLT=.FALSE.
! Output stack info
LSTACK=.FALSE.
! Use FFTW
LFFTW=.TRUE.

! Default number of vertical levels
NFLEVG=137
! Number of 3D grid-point fields in GMV
NDIMGMV=9
! Number of 2D grid-point fields in GMVS
! surface pressure, north south der, east-west der
NDIMGMVS=3 
! Set defaults for options
CINSF   = ' '
CTYPEG  = 'r'
LSTDEV    = .FALSE.
NLIN    = 1
NDGL    = 0
NQ      = 0
CRTABLE = '.'

! Locals
ILASTLEV = 0

! Read NAMELIST to override defaults
REWIND(NULNAM)
READ(NULNAM,NAMTRANS)

! Message passing setup
! Participating processors limited by -P option

!--------------------------
CALL MPL_INIT(LDENV=.false.)
!IF( LSTATS ) CALL GSTATS(0,0)
ZTINIT=TIMEF()

NPROC= MPL_NPROC()
MYPROC = MPL_MYRANK()
NTHREAD= OML_MAX_THREADS()

! ONLY OUTPUT TO STDOUT ON PE 1
IF( NPROC > 1 ) THEN
  IF( MYPROC /= 1 ) THEN
    OPEN(UNIT=NOUT, FILE='/dev/null')
  ENDIF
ENDIF

IF(LDETAILED_STATS)THEN
  LSTATS_OMP=.TRUE.
  LSTATS_COMMS=.TRUE.
  LSTATS_MPL=.TRUE.
  LSTATSCPU=.TRUE.
  NPRNT_STATS=NPROC
!  LSTATS_MEM=.TRUE.
!  LSTATS_ALLOC=.TRUE.
ENDIF

!-------------------------

ALLOCATE(NPRCIDS(NPROC))
DO JJ=1,NPROC
  NPRCIDS(JJ) = JJ
ENDDO

IF( NPROC <= 1 ) LMPOFF=.TRUE.
! COMPUTE NPRGPNS and NPRGPEW
! THIS VERSION SELECTS MOST SQUARE-LIKE DISTRIBUTION
! THESE WILL CHANGE IF LEQ_REGIONS=.TRUE.
IF( NPROC == 0 ) NPROC = 1
ISQR=INT(SQRT(REAL(NPROC,JPRB)))
DO JA=ISQR,NPROC
  IB=NPROC/JA
  IF( JA*IB == NPROC ) THEN
    NPRGPNS=MAX(JA,IB)
    NPRGPEW=MIN(JA,IB)
    EXIT
  ENDIF
ENDDO

! FROM SUMPINI, ALTHOUGH THIS
! SHOULD BE SPECIFIED IN NAMELIST
IF( NSPECRESMIN==0 ) NSPECRESMIN=NPROC

! COMPUTE NPRTRV AND NPRTRW 
! IF NOT PROVIDED IN NAMELIST
IF( NPRTRV > 0 .OR. NPRTRW > 0 ) THEN
  IF( NPRTRV == 0 ) NPRTRV=NPROC/NPRTRW
  IF( NPRTRW == 0 ) NPRTRW=NPROC/NPRTRV
  IF( NPRTRW*NPRTRV /= NPROC ) CALL ABOR1('TRANSFORM_TEST:NPRTRW*NPRTRV /= NPROC')
  IF( NPRTRW > NSPECRESMIN ) CALL ABOR1('TRANSFORM_TEST:NPRTRW > NSPECRESMIN')
ELSE
  DO JPRTRV=4,NPROC
    NPRTRV=JPRTRV
    NPRTRW=NPROC/NPRTRV
    IF( NPRTRV*NPRTRW /= NPROC ) CYCLE
    IF( NPRTRV > NPRTRW ) EXIT
    IF( NPRTRW > NSPECRESMIN ) CYCLE
! With CUDA AWARE MPI we don't need any OpenMP so there is no need for this! Effectively this is even
! undesireable because it may trigger different domain decompositions for no reasons on different machines
#ifndef USE_CUDA_AWARE_MPI_FT
    IF( NPRTRW <= NSPECRESMIN/(2*OML_MAX_THREADS()) ) EXIT
#endif
  ENDDO
  ! GO FOR APPROX SQUARE PARTITION FOR BACKUP
  IF( NPRTRV*NPRTRW /= NPROC .OR. NPRTRW > NSPECRESMIN .OR. NPRTRV > NPRTRW ) THEN
    ISQR=INT(SQRT(REAL(NPROC,JPRB)))
    DO JA=ISQR,NPROC
      IB=NPROC/JA
      IF (JA*IB == NPROC) THEN
        NPRTRW=MAX(JA,IB)
        NPRTRV=MIN(JA,IB)
        IF (NPRTRW > NSPECRESMIN ) CALL ABOR1('TRANSFORM_TEST:NPRTRW &
                                           & (approx square value) > NSPECRESMIN')
        EXIT
      ENDIF
    ENDDO
  ENDIF
ENDIF

! Create communicators for MPI groups
IF (.NOT.LMPOFF) THEN
  CALL MPL_GROUPS_CREATE(NPRTRW,NPRTRV)
ENDIF

IF (LMPOFF) THEN
  MYSETW=(MYPROC-1)/NPRTRV+1
  MYSETV=MOD(MYPROC-1,NPRTRV)+1
ELSE
  CALL MPL_CART_COORDS(MYPROC,MYSETW,MYSETV)
  ! Just checking for now...
  IPRTRV=MOD(MYPROC-1,NPRTRV)+1
  IPRTRW=(MYPROC-1)/NPRTRV+1
  IF (IPRTRV/=MYSETV .OR. IPRTRW/=MYSETW) THEN
    CALL ABOR1('TRANSFORM_TEST:Inconsistency when computing MYSETW and MYSETV')
  ENDIF
ENDIF

IF (.NOT.LMPOFF) THEN
  LLINFO=.FALSE.
  IF (MYPROC == 1) LLINFO=.TRUE.
  CALL MPL_BUFFER_METHOD(KMP_TYPE=MP_TYPE,KMBX_SIZE=MBX_SIZE,KPROCIDS=NPRCIDS,LDINFO=LLINFO)
ENDIF

! Determine number of local levels for Fourier and Legendre calculations
! based on the values of NFLEVG and NPRTRV
ALLOCATE(NUMLL(NPRTRV+1))

ALLOCATE(NPSURF(NPRTRV))

! Calculate remainder
IPRUSED=MIN(NFLEVG+1,NPRTRV)
ILEVPP=NFLEVG/NPRTRV
IREST=NFLEVG-ILEVPP*NPRTRV
DO JROC=1,NPRTRV
  IF(JROC <= IREST) THEN
    NUMLL(JROC)=ILEVPP+1
  ELSE
    NUMLL(JROC)=ILEVPP
  ENDIF
ENDDO
NUMLL(IPRUSED+1:NPRTRV+1)=0

NFLEVL=NUMLL(MYSETV) 

DO JROC=1,IPRUSED
  NPSURF(JROC)=0
ENDDO
NPSURF(IPRUSED)=1
NPSP=NPSURF(MYSETV)
IVSETSC(1)=IPRUSED

ITAG = 123456
IFLD=0
IFLDS=0

IF(MYPROC == 1) THEN
  IF(CINSF == ' ') THEN
    CINSF = 'fort.11'
  ENDIF
ENDIF

IF(CTYPEG == 'r') THEN
  NTYPE = 1
ELSEIF(CTYPEG == 'f') THEN
  NTYPE = 0
ELSE
  WRITE(NERR,*) 'WRONG TYPE OF GRID: ',CTYPEG,'  It should be',' either f or r'
  CALL ABOR1('TRANSFORM_TEST:WRONG TYPE OF GRID')
ENDIF

ICODE = 0

! Find spectral resolution

IF(MYPROC == 1) THEN
  CALL GRIB_OPEN_FILE(INSF,CINSF,'R',IRET)
  IF(IRET /= GRIB_SUCCESS) THEN
    WRITE(NERR,*) 'ERROR OPENING FILE INPUT SPECTRAL FILE',CINSF,IRET
    CALL ABOR1('TRANSFORM_TEST: ERROR OPENING FILE INPUT SPECTRAL FILE')
  ENDIF
  CALL GRIB_NEW_FROM_FILE(INSF,IGRIB(1),IRET)
  IF(IRET /= GRIB_SUCCESS) THEN
    WRITE(NERR,*)'ERROR IN FILE ',CINSF,' : NO INFORMATION'
    CALL ABOR1('TRANSFORM_TEST: ERROR GRIB_NEW_FROM_FILE')
  ENDIF
  CALL GRIB_GET(IGRIB(1),'gridType',CGRIDTYPE,IRET)
  IF(CGRIDTYPE /= 'sh') THEN
    WRITE(NERR,*)'INPUT DATA NOT IN SPECTRAL FORM'
    CALL ABOR1('TRANSFORM_TEST:INPUT DATA NOT IN SPECTRAL FORM')
  ENDIF

  CALL GRIB_GET(IGRIB(1),'pentagonalResolutionParameterJ',NSMAX)

! Decide gridpoint resolution

  IF (NDGL == 0) THEN
    CALL SETNDGL
  ELSE
    CALL CHECK_NDGL
  ENDIF
ENDIF

IF(NPROC > 1) THEN
  CALL MPL_BROADCAST(NSMAX,KROOT=1,KTAG=ITAG, &
           &   CDSTRING='TRANSFORM_TEST:')

  CALL MPL_BROADCAST(NDGL,KROOT=1,KTAG=ITAG, &
           &   CDSTRING='TRANSFORM_TEST:')
ENDIF
ALLOCATE(NLOEN(NDGL))

IF(MYPROC == 1) THEN

  IF(NTYPE == 0) THEN
    NLOEN(:) = 2*NDGL
  ELSEIF(NQ == 1.AND.NTYPE == 1) THEN
    ! cubic grid
    ITABLE = INDEX(CRTABLE,' ')
    IF(NSMAX < 1000) THEN
      WRITE(CRTABLE(ITABLE:ITABLE+11),'(A,I3.3)') '/rtable_3',NSMAX
    ELSE
      WRITE(CRTABLE(ITABLE:ITABLE+12),'(A,I4.4)') '/rtable_3',NSMAX
    ENDIF
  ELSEIF(NQ == 2.AND.NTYPE == 1) THEN
    ! cubic grid + Collignon
    ITABLE = INDEX(CRTABLE,' ')
    IF(NSMAX < 1000) THEN
      WRITE(CRTABLE(ITABLE:ITABLE+11),'(A,I3.3)') '/rtable_4',NSMAX
    ELSE
      WRITE(CRTABLE(ITABLE:ITABLE+12),'(A,I4.4)') '/rtable_4',NSMAX
    ENDIF
  ELSEIF(NLIN == 0.AND.NTYPE == 1) THEN
    ! quadratic grid
    ITABLE = INDEX(CRTABLE,' ')
    IF(NSMAX < 1000) THEN
      WRITE(CRTABLE(ITABLE:ITABLE+11),'(A,I3.3)') '/rtable_2',NSMAX
    ELSE
      WRITE(CRTABLE(ITABLE:ITABLE+12),'(A,I4.4)') '/rtable_2',NSMAX
    ENDIF
  ELSEIF(NLIN == 1.AND.NTYPE == 1) THEN
    ITABLE = INDEX(CRTABLE,' ')
    IF(NSMAX < 1000) THEN
      WRITE(CRTABLE(ITABLE:ITABLE+12),'(A,I3.3)') '/rtablel_2',NSMAX
    ELSE
      WRITE(CRTABLE(ITABLE:ITABLE+13),'(A,I4.4)') '/rtablel_2',NSMAX
    ENDIF
  ENDIF
  IF(NTYPE == 1) THEN
    OPEN(15,FILE=CRTABLE,FORM='FORMATTED',ACTION='READ')
    READ(15,NAMRGRI)
    NLOEN(:) = NRGRI(1:NDGL)
    CLOSE(15)
  ENDIF

  CALL GRIB_RELEASE(IGRIB(1))
  CALL GRIB_CLOSE_FILE(INSF)

ENDIF


IF(NPROC > 1) THEN
  CALL MPL_BROADCAST(NLOEN(:),KROOT=1,KTAG=ITAG, &
           &   CDSTRING='TRANSFORM_TEST:')
ENDIF

CALL SETUP_TRANS0(KOUT=NOUT,KERR=NERR,KPRINTLEV=NPRINTLEV,KMAX_RESOL=NMAX_RESOL, &
&                 KPROMATR=NPROMATR,KPRGPNS=NPRGPNS,KPRGPEW=NPRGPEW,KPRTRW=NPRTRW, &
&                 KCOMBFLEN=NCOMBFLEN,LDMPOFF=LMPOFF,LDSYNC_TRANS=LSYNC_TRANS, &
&                 LDEQ_REGIONS=LEQ_REGIONS, &
&                 PRAD=ZRA,LDALLOPERM=.TRUE.)

CALL SETUP_TRANS(KSMAX=NSMAX,KDGL=NDGL,KLOEN=NLOEN,LDSPLIT=.TRUE.,&
&                 KFLEV=NFLEVL, LDUSEFFTW=LFFTW,&
&                 LDUSERPNM=LUSERPNM,LDKEEPRPNM=LKEEPRPNM,LDUSEFLT=LUSEFLT)
!
CALL TRANS_INQ(KSPEC2=NSPEC2,KSPEC2G=NSPEC2G,KGPTOT=NGPTOT,KGPTOTG=NGPTOTG)


! Default, no blocking
NPROMA=NGPTOT
! allow NPROMA to be overidden by namelist value
REWIND(NULNAM)
READ(NULNAM,NAMTRANS)
! Calculate number of NPROMA blocks
NGPBLKS=(NGPTOT-1)/NPROMA+1

! Allocate spectral arrays
! Try to mimick IFS layout as much as possible
NULLIFY(ZVOR)
NULLIFY(ZDIV)
NULLIFY(ZT)
ALLOCATE(SP3D(NFLEVL,NSPEC2,3))
ALLOCATE(ZSP(1,NSPEC2))

SP3D(:,:,:)=0.0_JPRB
ZSP(:,:)   =0.0_JPRB
ZVOR    =>SP3D(:,:,1)
ZDIV    =>SP3D(:,:,2)
ZT      =>SP3D(:,:,3:3)

! Spectral global buffers
! Allocating only on PE 1
! Dangerous, but otherwise we run out of memory 
! if we run flat MPI
IF(MYPROC == 1) THEN
  ALLOCATE(ZFPDAT(NSPEC2G))
  ALLOCATE(ZSPVORG(NFLEVG,NSPEC2G))
  ALLOCATE(ZSPDIVG(NFLEVG,NSPEC2G))
  ALLOCATE(ZSPTG(NFLEVG,NSPEC2G,1))
  ALLOCATE(ZSPSPG(1,NSPEC2G))
ENDIF

! Open files
IF(MYPROC == 1) THEN
  CALL GRIB_OPEN_FILE(INSF,CINSF,'R',IRET)
  IF(IRET /= GRIB_SUCCESS) THEN
    WRITE(NERR,*) 'ERROR OPENING FILE INPUT SPECTRAL FILE',CINSF,IRET
    CALL ABOR1('TRANSFORM_TEST:ERROR OPENING FILE INPUT SPECTRAL FILE')
  ENDIF
ENDIF

! Spectral to gridpoint transform
LDONE = .FALSE.

! specify the maximum number of fields to be read from input dataset
! it is not a problem if there are less fields as the actual number of fields
! that will transformed will be replicated from the actual number of fields read
IMAX_FLDS_IN=412

! allow IMAX_FLDS_IN to be overidden by namelist value
REWIND(NULNAM)
READ(NULNAM,NAMTRANS)

! Inititialize GRIB_API handles to zero
IGRIB(:) = 0
IGRIBOUT = 0

DO
  IF(MYPROC == 1) THEN

    ! Read and decode spectral field
!   WRITE(NOUT,*) ' CALLING GRIB_NEW_FROM_FILE' 
    CALL GRIB_NEW_FROM_FILE(INSF,IGRIB(1),IRET)
    IF(IRET == GRIB_END_OF_FILE) THEN
      LDONE = .TRUE.
      WRITE(NOUT,'(A)') 'END OF GRIB FILE REACHED.'
    ENDIF

    IF(IFLDS==IMAX_FLDS_IN) THEN
      LDONE = .TRUE.
    ENDIF

    IF(.NOT. LDONE) THEN
      IF(IRET /= GRIB_SUCCESS) THEN
        WRITE(NERR,*) 'ERROR GRIB_NEW_FROM_FILE',IRET
        CALL ABOR1('TRANSFORM_TEST:ERROR GRIB_NEW_FROM_FILE')
      ENDIF

      CALL GRIB_GET(IGRIB(1),'edition',IEDITION(1),IRET)
      IF(IRET /= GRIB_SUCCESS) THEN
        WRITE(NERR,*)'ERROR GRIB_GET edition'
        CALL ABOR1('TRANSFORM_TEST:ERROR GRIB_GET edition')
      ENDIF

      CALL GRIB_GET(IGRIB(1),'paramId',IPARAM(1),IRET)
      IF(IRET /= GRIB_SUCCESS) THEN
        WRITE(NERR,*)'ERROR GRIB_GET paramId'
        CALL ABOR1('TRANSFORM_TEST:ERROR GRIB_GET paramId')
      ENDIF
    
      ! Write out "skipped field" to output spectral file
      IF(IPARAM(1) /= ICODE.AND.ICODE /= 0) THEN
        PRINT *,'FIELD ',IPARAM(1),' NOT TRANSFORMED'
        CALL GRIB_CLONE(IGRIB(1),IGRIBOUT,IRET)
        IF(IRET /= GRIB_SUCCESS) THEN
          WRITE(NERR,*)'TRANSFORM_TEST:ERROR GRIB_CLONE'
          CALL ABOR1('TRANSFORM_TEST:ERROR GRIB_CLONE')
        ENDIF
        CALL GRIB_WRITE(IGRIBOUT,IOUTSF,IRET)
        IF(IRET /= GRIB_SUCCESS) THEN
          WRITE(NERR,*)'TRANSFORM_TEST:ERROR GRIB_WRITE'
          CALL ABOR1('TRANSFORM_TEST:ERROR GRIB_WRITE')
        ENDIF
        CALL GRIB_RELEASE(IGRIBOUT)
        CYCLE
      ENDIF

      CALL GRIB_GET(IGRIB(1),'level',ICURLEV,IRET)
      IF( IRET /= GRIB_SUCCESS) THEN
        WRITE(NERR,*)'ERROR GRIB_GET level'
        CALL ABOR1('TRANSFORM_TEST:ERROR GRIB_GET level')
      ENDIF

      CALL GRIB_GET(IGRIB(1),'shortName',CFNAME,IRET)
      IF( IRET /= GRIB_SUCCESS) THEN
        WRITE(NERR,*)'ERROR GRIB_GET shortName'
        CALL ABOR1('TRANSFORM_TEST:ERROR GRIB_GET shortName')
      ENDIF

      CALL GRIB_GET(IGRIB(1),'values',ZFPDAT,IRET)
      IF(IRET /= GRIB_SUCCESS) THEN
        WRITE(NERR,*)'ERROR GRIB_GET values ',IRET
        CALL ABOR1('TRANSFORM_TEST:ERROR GRIB_GET values')
      ENDIF
      CALL GRIB_RELEASE(IGRIB(1))
      IFLD=1
      ILEV=ICURLEV(1)
      ILASTLEV = MAX(ILEV,ILASTLEV)

      IF( CFNAME == 'lnsp' ) THEN
        ZSPSPG(1,:)=ZFPDAT(:)
        IFLDS=IFLDS+1
      ENDIF

      IF( CFNAME == 'vo' ) THEN
        ZSPVORG(ILEV,:)=ZFPDAT(:)
        IFLDS=IFLDS+1
      ENDIF

      IF( CFNAME == 'd' ) THEN
        ZSPDIVG(ILEV,:)=ZFPDAT(:)
        IFLDS=IFLDS+1
      ENDIF

      IF( CFNAME == 't' ) THEN
        ZSPTG(ILEV,:,1)=ZFPDAT(:)
        IFLDS=IFLDS+1
      ENDIF
    ENDIF
    ! Send number of fields in this batch to other processors
    IF(NPROC > 1) THEN
      DO JROC=2,NPROC
        CALL MPL_SEND(IFLD,KDEST=NPRCIDS(JROC),KTAG=ITAG)
      ENDDO
    ENDIF

  ELSE
    ! Receive field
    CALL MPL_RECV(IFLD,KSOURCE=NPRCIDS(1),KTAG=ITAG)
  ENDIF

  IF(NPROC > 1 .AND. IFLD == 1) THEN
    CALL MPL_BROADCAST(IPARAM(IFLD),KROOT=1,KTAG=ITAG, &
             &   CDSTRING='TRANSFORM_TEST:')
  ENDIF
  IF(IFLD == 0 ) EXIT
  
  ! Synchronize processors
  IF(NPROC > 1) THEN
    CALL MPL_BARRIER()
  ENDIF
! Distribute batch of fields

  IFLD = 0
ENDDO


IF (MYPROC == 1) THEN
  CALL GRIB_CLOSE_FILE(INSF)
ENDIF

! Broadcast number of fields read to all procs and levels
IF(NPROC > 1) THEN
  CALL MPL_BROADCAST(IFLDS,KROOT=1,KTAG=ITAG, &
             &   CDSTRING='TRANSFORM_TEST:')
  CALL MPL_BROADCAST(ILASTLEV,KROOT=1,KTAG=ITAG, &
             &   CDSTRING='TRANSFORM_TEST:')

ENDIF

! Some sanity checks
IF( ILASTLEV < 1 ) CALL ABOR1('TRANSFORM_TEST:ILASTLEV < 1')
IF( NFLEVG < ILASTLEV ) CALL ABOR1('TRANSFORM_TEST:NFLEVG < ILASTLEV')

! Extend fields using mod function
IF( NFLEVG > ILASTLEV ) THEN
  IF( MYPROC == 1 ) THEN
    DO ILEV=ILASTLEV+1,NFLEVG
      ZSPVORG(ILEV,:) = ZSPVORG(MOD(ILEV-1,ILASTLEV)+1,:)
      ZSPDIVG(ILEV,:) = ZSPDIVG(MOD(ILEV-1,ILASTLEV)+1,:)
      ZSPTG(ILEV,:,1) = ZSPTG(MOD(ILEV-1,ILASTLEV)+1,:,1)
    ENDDO
  ENDIF
ENDIF

WRITE(NOUT,'(" ")')
WRITE(NOUT,'("SPECTRAL FIELDS HAVE BEEN SUCCESSFULY READ, IFLDS=",I3)')IFLDS
WRITE(NOUT,'(" ")')

! PRINT CONFIGURATION DETAILS
WRITE(NOUT,'(A)')'===-=== START OF  RUNTIME PARAMETERS ===-==='
WRITE(NOUT,'(" ")')
WRITE(NOUT,'("NLIN=   ",I10)') NLIN
WRITE(NOUT,'("NQ=     ",I10)') NQ
WRITE(NOUT,'("NSMAX=  ",I10)') NSMAX
WRITE(NOUT,'("NDGL=   ",I10)') NDGL
WRITE(NOUT,'("NPROC=  ",I10)') NPROC
WRITE(NOUT,'("NTHREAD=",I10)') NTHREAD
WRITE(NOUT,'("NPRGPNS=",I10)') NPRGPNS
WRITE(NOUT,'("NPRGPEW=",I10)') NPRGPEW
WRITE(NOUT,'("NPRTRW= ",I10)') NPRTRW
WRITE(NOUT,'("NPRTRV= ",I10)') NPRTRV
WRITE(NOUT,'("NPROMA= ",I10)') NPROMA
WRITE(NOUT,'("NGPTOT= ",I10)') NGPTOT
WRITE(NOUT,'("NGPTOTG=",I10)') NGPTOTG
WRITE(NOUT,'("NFLEVG= ",I10)') NFLEVG
WRITE(NOUT,'("IFLDS=  ",I10)') IFLDS
WRITE(NOUT,'("NSPEC2= ",I10)') NSPEC2
WRITE(NOUT,'("NSPEC2G=",I10)') NSPEC2G
WRITE(NOUT,'("LUSEFLT=",L10)') LUSEFLT
WRITE(NOUT,'(" ")')
WRITE(NOUT,'(A)') '===-=== END OF   RUNTIME PARAMETERS ===-==='


ALLOCATE(IVSET(NFLEVG))

! Compute spectral distribution
ILEV = 0
DO JB=1,NPRTRV
  DO JLEV=1,NUMLL(JB)
    ILEV = ILEV + 1
    IVSET(ILEV) = JB
  ENDDO
ENDDO

ALLOCATE(ITO(IFLDS))
ITO(:)=1

! Distribute spectral fields to processors
CALL DIST_SPEC(PSPECG=ZSPVORG,KFDISTG=NFLEVG,KFROM=ITO,PSPEC=ZVOR,KVSET=IVSET(1:NFLEVG))
CALL DIST_SPEC(PSPECG=ZSPDIVG,KFDISTG=NFLEVG,KFROM=ITO,PSPEC=ZDIV,KVSET=IVSET(1:NFLEVG))
CALL DIST_SPEC(PSPECG=ZSPTG(:,:,1),KFDISTG=NFLEVG,KFROM=ITO,PSPEC=ZT(:,:,1),KVSET=IVSET(1:NFLEVG))
CALL DIST_SPEC(PSPECG=ZSPSPG,KFDISTG=1,KFROM=ITO,PSPEC=ZSP,KVSET=IVSETSC(1:1))

! Deallocate resources
IF(MYPROC==1) THEN
  DEALLOCATE(ZFPDAT,ITO)
  DEALLOCATE(ZSPVORG,ZSPDIVG,ZSPTG,ZSPSPG)
ENDIF
! ALLOCATE GRID-POINT ARRAYS
ALLOCATE(ZWINDS(NPROMA,NFLEVG,4,NGPBLKS))
ALLOCATE(ZGMV(NPROMA,NFLEVG,NDIMGMV,NGPBLKS))
ALLOCATE(ZGMVS(NPROMA,NDIMGMVS,NGPBLKS))

ALLOCATE(PMIN(NFLEVG))
ALLOCATE(PMAX(NFLEVG))
ALLOCATE(PAVE(NFLEVG))

ALLOCATE(ZNORMSP(1))
ALLOCATE(ZNORMSP1(1))
ALLOCATE(ZNORMVOR(NFLEVG))
ALLOCATE(ZNORMVOR1(NFLEVG))
ALLOCATE(ZNORMDIV(NFLEVG))
ALLOCATE(ZNORMDIV1(NFLEVG))
ALLOCATE(ZNORMT(NFLEVG))
ALLOCATE(ZNORMT1(NFLEVG))

IF( NPRINTNORMS > 0 ) THEN
  CALL SPECNORM(PSPEC=ZVOR(1:NFLEVL,:),PNORM=ZNORMVOR1,KVSET=IVSET(1:NFLEVG))
  CALL SPECNORM(PSPEC=ZDIV(1:NFLEVL,:),PNORM=ZNORMDIV1,KVSET=IVSET(1:NFLEVG))
  CALL SPECNORM(PSPEC=ZT(1:NFLEVL,:,1),PNORM=ZNORMT1,KVSET=IVSET(1:NFLEVG))
  CALL SPECNORM(PSPEC=ZSP(1:1,:),      PNORM=ZNORMSP1,KVSET=IVSETSC(1:1))

  IF(MYPROC == 1) THEN
    DO IFLD=1,1
      WRITE(NOUT,'("SP  ZNORM(",I4,")=",F20.15)') IFLD,ZNORMSP1(IFLD)
    ENDDO
    DO IFLD=1,NFLEVG
      WRITE(NOUT,'("DIV ZNORM(",I4,")=",F20.15)') IFLD,ZNORMDIV1(IFLD)
    ENDDO
    DO IFLD=1,NFLEVG
      WRITE(NOUT,'("VOR ZNORM(",I4,")=",F20.15)') IFLD,ZNORMVOR1(IFLD)
    ENDDO
    DO IFLD=1,NFLEVG
      WRITE(NOUT,'("T   ZNORM(",I4,")=",F20.15)') IFLD,ZNORMT1(IFLD)
    ENDDO
  ENDIF
ENDIF

ZTINIT=(TIMEF()-ZTINIT)/1000.0_JPRD
WRITE(NOUT,'(" ")')
WRITE(NOUT,'(a,I6,a,F9.2,a)') "TRANSFORM_TEST initialisation, on",NPROC,&
                              & " tasks, took",ZTINIT," sec"
WRITE(NOUT,'(" ")')

IF(ITERS<=0) CALL ABOR1('TRANSFORM_TEST:ITERS <= 0')

ALLOCATE(ZTSTEP(ITERS))
ALLOCATE(ZTSTEP1(ITERS))
ALLOCATE(ZTSTEP2(ITERS))

ZTSTEPAVG=0._JPRD
ZTSTEPMAX=0._JPRD
ZTSTEPMIN=9999999999999999._JPRD
ZTSTEPAVG1=0._JPRD
ZTSTEPMAX1=0._JPRD
ZTSTEPMIN1=9999999999999999._JPRD
ZTSTEPAVG2=0._JPRD
ZTSTEPMAX2=0._JPRD
ZTSTEPMIN2=9999999999999999._JPRD

WRITE(NOUT,'(A)') '===-=== START OF  SPEC TRANSFORMS  ===-==='
WRITE(NOUT,'(" ")')

IF( LSTATS ) THEN 
  CALL GSTATS(0,0)
  CALL GSTATS_SETUP(NPROC,MYPROC,NPRCIDS,&
   & LSTATS,LSTATSCPU,LSYNCSTATS,LDETAILED_STATS,LBARRIER_STATS,LBARRIER_STATS2,&
   & LSTATS_OMP,LSTATS_COMMS,LSTATS_MEM,NSTATS_MEM,LSTATS_ALLOC,&
   & LTRACE_STATS,NTRACE_STATS,NPRNT_STATS,LXML_STATS)
  CALL GSTATS_PSUT
  CALL GSTATS_LABEL_IFS
ENDIF

ZTLOOP=TIMEF()
! simulated time stepping loop

!skip time measurements for first iteration
YLSTATS = .false.

DO JSTEP=1,ITERS
  IF (JSTEP > 1) YLSTATS = .true.
  ZTSTEP(JSTEP)=TIMEF()
  ZTSTEP1(JSTEP)=TIMEF()
  CALL INV_TRANS(PSPVOR=ZVOR,PSPDIV=ZDIV,PSPSC2=ZSP(1:1,:),&
     & PSPSC3A=ZT,&
     & LDSCDERS=.TRUE.,LDVORGP=.FALSE.,LDDIVGP=.TRUE.,LDUVDER=.FALSE.,&
     & KRESOL=1,KPROMA=NPROMA,KVSETUV=IVSET,KVSETSC2=IVSETSC(1:1),&
     & KVSETSC3A=IVSET,&
     & PGPUV=ZWINDS(:,:,2:4,:),PGP2=ZGMVS(:,1:3,:),&
     & PGP3A=ZGMV(:,:,5:7,:))
  ZTSTEP1(JSTEP)=(TIMEF()-ZTSTEP1(JSTEP))/1000.0_JPRD

  ! Dump a field to a binary file
  IF (LDUMP) CALL DUMP_GRIDPOINT_FIELD_3D(JSTEP, MYPROC, ZGMVS(:,:,:), 'S', NOUTDUMP)
  IF (LDUMP) CALL DUMP_GRIDPOINT_FIELD_4D(JSTEP, MYPROC, ZWINDS(:,:,:,:),  'W', NOUTDUMP)
  IF (LDUMP) CALL DUMP_GRIDPOINT_FIELD_4D(JSTEP, MYPROC, ZGMV(:,:,:,:),  'M', NOUTDUMP)

  ZTSTEP2(JSTEP)=TIMEF()
  CALL DIR_TRANS(PSPVOR=ZVOR,PSPDIV=ZDIV,&
      & PSPSC2=ZSP(1:1,:),PSPSC3A=ZT,&
      & KRESOL=1,KPROMA=NPROMA,KVSETUV=IVSET,KVSETSC2=IVSETSC(1:1),&
      & KVSETSC3A=IVSET,&
      & PGPUV=ZWINDS(:,:,3:4,:),PGP2=ZGMVS(:,1:1,:),&
      & PGP3A=ZGMV(:,:,5:5,:))
  ZTSTEP2(JSTEP)=(TIMEF()-ZTSTEP2(JSTEP))/1000.0_JPRD

  ! Dump a field to a binary file
  IF (LDUMP) CALL DUMP_GRIDPOINT_FIELD_2D(JSTEP, MYPROC, ZVOR(:,:), 'V', NOUTDUMP)
  IF (LDUMP) CALL DUMP_GRIDPOINT_FIELD_2D(JSTEP, MYPROC, ZDIV(:,:),  'D', NOUTDUMP)
  IF (LDUMP) CALL DUMP_GRIDPOINT_FIELD_2D(JSTEP, MYPROC, ZSP(:,:), 'P', NOUTDUMP)
  IF (LDUMP) CALL DUMP_GRIDPOINT_FIELD_3D(JSTEP, MYPROC, ZT(:,:,:),  'T', NOUTDUMP)

  ZTSTEP(JSTEP)=(TIMEF()-ZTSTEP(JSTEP))/1000.0_JPRD

  ZTSTEPAVG=ZTSTEPAVG+ZTSTEP(JSTEP)
  ZTSTEPMIN=MIN(ZTSTEP(JSTEP),ZTSTEPMIN)
  ZTSTEPMAX=MAX(ZTSTEP(JSTEP),ZTSTEPMAX)

  ZTSTEPAVG1=ZTSTEPAVG1+ZTSTEP1(JSTEP)
  ZTSTEPMIN1=MIN(ZTSTEP1(JSTEP),ZTSTEPMIN1)
  ZTSTEPMAX1=MAX(ZTSTEP1(JSTEP),ZTSTEPMAX1)

  ZTSTEPAVG2=ZTSTEPAVG2+ZTSTEP2(JSTEP)
  ZTSTEPMIN2=MIN(ZTSTEP2(JSTEP),ZTSTEPMIN2)
  ZTSTEPMAX2=MAX(ZTSTEP2(JSTEP),ZTSTEPMAX2)


  IF( NPRINTNORMS > 1 )THEN 
    CALL SPECNORM(PSPEC=ZSP(1:1,:),       PNORM=ZNORMSP, KVSET=IVSETSC(1:1))
    CALL SPECNORM(PSPEC=ZVOR(1:NFLEVL,:), PNORM=ZNORMVOR,KVSET=IVSET(1:NFLEVG))
    CALL SPECNORM(PSPEC=ZDIV(1:NFLEVL,:), PNORM=ZNORMDIV,KVSET=IVSET(1:NFLEVG))
    CALL SPECNORM(PSPEC=ZT(1:NFLEVL,:,1), PNORM=ZNORMT, KVSET=IVSET(1:NFLEVG))

    IF( MYPROC==1 ) THEN
      ! SURFACE PRESSURE
      ZMAXERR(:)=-999.0
      DO IFLD=1,1
        ZERR(1)=ABS(ZNORMSP1(IFLD)/ZNORMSP(IFLD)-1.0_JPRB)
        ZMAXERR(1)=MAX(ZMAXERR(1),ZERR(1))
      ENDDO
      ! DIVERGENCE
      DO IFLD=1,NFLEVG
        ZERR(2)=ABS(ZNORMDIV1(IFLD)/ZNORMDIV(IFLD)-1.0_JPRB)
        ZMAXERR(2)=MAX(ZMAXERR(2),ZERR(2))
      ENDDO
      ! VORTICITY
      DO IFLD=1,NFLEVG
        ZERR(3)=ABS(ZNORMVOR1(IFLD)/ZNORMVOR(IFLD)-1.0_JPRB)
        ZMAXERR(3)=MAX(ZMAXERR(3),ZERR(3))
      ENDDO
      ! TEMPERATURE
      DO IFLD=1,NFLEVG
        ZERR(4)=ABS(ZNORMT1(IFLD)/ZNORMT(IFLD)-1.0_JPRB)
        ZMAXERR(4)=MAX(ZMAXERR(4),ZERR(4))
      ENDDO
      WRITE(NOUT,'("time step ",I6," took", F8.4," | SP max err="E10.3,&
                 & " | DIV max err="E10.3," | VOR max err="E10.3," | T max err="E10.3)') & 
                 &  JSTEP,ZTSTEP(JSTEP),ZMAXERR(1),ZMAXERR(2),ZMAXERR(3),ZMAXERR(4)
    ENDIF
  ELSE
    WRITE(NOUT,'("time step ",I6," took", F8.4)') JSTEP,ZTSTEP(JSTEP)
  ENDIF
  flush(nout)
  ! call acc_present_dump()
  ! print *, "going to free in 3 seconds"
  ! call sleep (1)
  ! print *, "going to free in 2 seconds"
  ! call sleep (1)
  ! print *, "going to free in 1 seconds"
  ! call sleep (1)
  ! !call acc_clear_freelists()
  ! call sleep (5)
  ! !call acc_present_dump()
  ! !call sleep (10000)
ENDDO

CALL GPNORM_TRANS(ZWINDS(:,:,2,:),NFLEVG,KPROMA=NPROMA,PAVE=PAVE,PMIN=PMIN,PMAX=PMAX,LDAVE_ONLY=.false.,KRESOL=1)
if (myproc == 1) then
    OPEN(800+myproc, FORM="UNFORMATTED")
    write(800+myproc) "pave", sum(pave)/size(pave)
    write(800+myproc) "pmin", sum(pmin)/size(pmin)
    write(800+myproc) "pmax", sum(pmax)/size(pmax)
    close(800+myproc)
    print *, "pave", sum(pave)/size(pave)
    print *, "pmin", sum(pmin)/size(pmin)
    print *, "pmax", sum(pmax)/size(pmax)
endif

ZTLOOP=(TIMEF()-ZTLOOP)/1000.0_JPRD

WRITE(NOUT,'(" ")')
WRITE(NOUT,'(A)') '===-=== END OF   SPEC TRANSFORMS  ===-==='
WRITE(NOUT,'(" ")')


IF( NPRINTNORMS > 0 ) THEN
  CALL SPECNORM(PSPEC=ZVOR(1:NFLEVL,:),PNORM=ZNORMVOR,KVSET=IVSET(1:NFLEVG))
  CALL SPECNORM(PSPEC=ZDIV(1:NFLEVL,:),PNORM=ZNORMDIV,KVSET=IVSET(1:NFLEVG))
  CALL SPECNORM(PSPEC=ZT(1:NFLEVL,:,1),PNORM=ZNORMT,KVSET=IVSET(1:NFLEVG))
  CALL SPECNORM(PSPEC=ZSP(1:1,:),      PNORM=ZNORMSP,KVSET=IVSETSC(1:1))

  IF(MYPROC == 1) THEN
    ! SURFACE PRESSURE
    ZMAXERR(:)=-999.0
    DO IFLD=1,1
      ZERR(1)=ABS(ZNORMSP1(IFLD)/ZNORMSP(IFLD)-1.0D0)
      ZMAXERR(1)=MAX(ZMAXERR(1),ZERR(1))
      WRITE(NOUT,'("SP ZNORM(",I4,")=",F20.15," ERR=",E10.3)') IFLD,ZNORMSP(IFLD),ZERR(1)
    ENDDO
    ! DIVERGENCE
    DO IFLD=1,NFLEVG
      ZERR(2)=ABS(ZNORMDIV1(IFLD)/ZNORMDIV(IFLD)-1.0D0)
      ZMAXERR(2)=MAX(ZMAXERR(2),ZERR(2))
      WRITE(NOUT,'("DIV ZNORM(",I4,")=",F20.15," ERR=",E10.3)') IFLD,ZNORMDIV(IFLD),ZERR(2)
    ENDDO
    ! VORTICITY
    DO IFLD=1,NFLEVG
      ZERR(3)=ABS(ZNORMVOR1(IFLD)/ZNORMVOR(IFLD)-1.0D0)
      ZMAXERR(3)=MAX(ZMAXERR(3),ZERR(3))
      WRITE(NOUT,'("VOR ZNORM(",I4,")=",F20.15," ERR=",E10.3)') IFLD,ZNORMVOR(IFLD),ZERR(3)
    ENDDO
    ! TEMPERATURE
    DO IFLD=1,NFLEVG
      ZERR(4)=ABS(ZNORMT1(IFLD)/ZNORMT(IFLD)-1.0D0)
      ZMAXERR(4)=MAX(ZMAXERR(4),ZERR(4))
      WRITE(NOUT,'("T ZNORM(",I4,")=",F20.15," ERR=",E10.3)') IFLD,ZNORMT(IFLD),ZERR(4)
    ENDDO
    ! MAXIMUM ERROR ACROSS ALL FIELDS
    ZMAXERRG=MAX(MAX(ZMAXERR(1),ZMAXERR(2)),MAX(ZMAXERR(2),ZMAXERR(3)))

    WRITE(NOUT,'("SURFACE PRESSURE MAX ERROR=",E10.3)')ZMAXERR(1)
    WRITE(NOUT,'("DIVERGENCE       MAX ERROR=",E10.3)')ZMAXERR(2)
    WRITE(NOUT,'("VORTICITY        MAX ERROR=",E10.3)')ZMAXERR(3)
    WRITE(NOUT,'("TEMPERATURE      MAX ERROR=",E10.3)')ZMAXERR(4)
    WRITE(NOUT,'("GLOBAL           MAX ERROR=",E10.3)')ZMAXERRG

  ENDIF
ENDIF

CALL MPL_ALLREDUCE(ZTLOOP,     'SUM', LDREPROD=.FALSE.)
CALL MPL_ALLREDUCE(ZTSTEP,     'SUM', LDREPROD=.FALSE.)
CALL MPL_ALLREDUCE(ZTSTEPAVG,  'SUM', LDREPROD=.FALSE.)
CALL MPL_ALLREDUCE(ZTSTEPMAX,  'MAX', LDREPROD=.FALSE.)
CALL MPL_ALLREDUCE(ZTSTEPMIN,  'MIN', LDREPROD=.FALSE.)

CALL MPL_ALLREDUCE(ZTSTEP1,    'SUM', LDREPROD=.FALSE.)
CALL MPL_ALLREDUCE(ZTSTEPAVG1, 'SUM', LDREPROD=.FALSE.)
CALL MPL_ALLREDUCE(ZTSTEPMAX1, 'MAX', LDREPROD=.FALSE.)
CALL MPL_ALLREDUCE(ZTSTEPMIN1, 'MIN', LDREPROD=.FALSE.)

CALL MPL_ALLREDUCE(ZTSTEP2,    'SUM', LDREPROD=.FALSE.)
CALL MPL_ALLREDUCE(ZTSTEPAVG2, 'SUM', LDREPROD=.FALSE.)
CALL MPL_ALLREDUCE(ZTSTEPMAX2, 'MAX', LDREPROD=.FALSE.)
CALL MPL_ALLREDUCE(ZTSTEPMIN2, 'MIN', LDREPROD=.FALSE.)


ZTSTEPAVG=(ZTSTEPAVG/REAL(NPROC,JPRB))/REAL(ITERS,JPRD)
ZTLOOP=ZTLOOP/REAL(NPROC,JPRD)
ZTSTEP(:)=ZTSTEP(:)/REAL(NPROC,JPRD)

CALL SORT(ZTSTEP,ITERS)
ZTSTEPMED = ZTSTEP(ITERS/2)

ZTSTEPAVG1=(ZTSTEPAVG1/REAL(NPROC,JPRB))/REAL(ITERS,JPRD)
ZTSTEP1(:)=ZTSTEP1(:)/REAL(NPROC,JPRD)

CALL SORT(ZTSTEP1,ITERS)
ZTSTEPMED1 = ZTSTEP1(ITERS/2)

ZTSTEPAVG2=(ZTSTEPAVG2/REAL(NPROC,JPRB))/REAL(ITERS,JPRD)
ZTSTEP2(:)=ZTSTEP2(:)/REAL(NPROC,JPRD)

CALL SORT(ZTSTEP2,ITERS)
ZTSTEPMED2 = ZTSTEP2(ITERS/2)

IF(MYPROC == 1)THEN
  WRITE(NOUT,'(" ")')
  WRITE(NOUT,'(A)') '===-=== START   OF TIME STEP STATS ===-==='
  WRITE(NOUT,'(" ")')
  WRITE(NOUT,'("INVERSE TRANSFORMS")')
  WRITE(NOUT,'("------------------")')
  WRITE(NOUT,'("AVG  (s): ",F8.4)') ZTSTEPAVG1
  WRITE(NOUT,'("MIN  (s): ",F8.4)') ZTSTEPMIN1
  WRITE(NOUT,'("MAX  (s): ",F8.4)') ZTSTEPMAX1
  WRITE(NOUT,'("MED  (s): ",F8.4)') ZTSTEPMED1
  WRITE(NOUT,'(" ")')
  WRITE(NOUT,'("DIRECT TRANSFORMS")')
  WRITE(NOUT,'("-----------------")')
  WRITE(NOUT,'("AVG  (s): ",F8.4)') ZTSTEPAVG2
  WRITE(NOUT,'("MIN  (s): ",F8.4)') ZTSTEPMIN2
  WRITE(NOUT,'("MAX  (s): ",F8.4)') ZTSTEPMAX2
  WRITE(NOUT,'("MED  (s): ",F8.4)') ZTSTEPMED2
  WRITE(NOUT,'(" ")')
  WRITE(NOUT,'("INVERSE-DIRECT TRANSFORMS")')
  WRITE(NOUT,'("-------------------------")')
  WRITE(NOUT,'("AVG  (s): ",F8.4)') ZTSTEPAVG
  WRITE(NOUT,'("MIN  (s): ",F8.4)') ZTSTEPMIN
  WRITE(NOUT,'("MAX  (s): ",F8.4)') ZTSTEPMAX
  WRITE(NOUT,'("MED  (s): ",F8.4)') ZTSTEPMED
  WRITE(NOUT,'("LOOP (s): ",F8.4)') ZTLOOP
  WRITE(NOUT,'(" ")')
  WRITE(NOUT,'(A)') '===-=== END     OF TIME STEP STATS ===-==='
  WRITE(NOUT,'(" ")')
ENDIF

IF( LSTACK ) THEN
!           gather stack usage statistics
  ISTACK = GETSTACKUSAGE()
  IF(MYPROC == 1) THEN
    PRINT 9000, istack
    9000 FORMAT("Stack Utilisation Information",/,&
         &"=============================",//,&
         &"Task           Size(Bytes)",/,&
         &"====           ===========",//,&
         &"   1",11x,I10)

    DO I=2,NPROC
      CALL MPL_RECV(ISTACK,KSOURCE=NPRCIDS(I),KTAG=I, &
           & CDSTRING='TRANSFORM_TEST:')
      PRINT '(I4,11X,I10)', I,ISTACK
    ENDDO
  ELSE
    CALL MPL_SEND(ISTACK,KDEST=NPRCIDS(1),KTAG=MYPROC, &
             &   CDSTRING='TRANSFORM_TEST:')
  ENDIF
ENDIF


!--------------------------
IF( LSTATS ) THEN
  CALL GSTATS(0,1)
  CALL GSTATS_PRINT(NOUT,ZAVEAVE,JPMAXSTAT)
ENDIF
!--------------------------

! CLOSE FILE
IF( NPROC > 1 ) THEN
  IF( MYPROC /= 1 ) THEN
    CLOSE(UNIT=NOUT)
  ENDIF
ENDIF

DEALLOCATE(ZWINDS)
DEALLOCATE(ZGMV)
DEALLOCATE(ZGMVS)

!--------------------------
CALL MPL_BARRIER()
CALL MPL_END()
!--------------------------




CONTAINS  

!     ------------------------------------------------------------------

SUBROUTINE SETNDGL

! Decide number of Gaussian latitudes given spectral truncation
! Only certain combinations of truncation/linear grid
! or quadratic grid are supported

!
!  See prepdata/programs/sptogp.F90
!

IF(NLIN == 0 .AND. (NQ == 1.OR.NQ == 2)) THEN
  IF(NSMAX == 79) THEN
    NDGL = 160
  ELSEIF(NSMAX == 95) THEN
    NDGL = 192
  ELSEIF(NSMAX == 127) THEN
    NDGL = 256
  ELSEIF(NSMAX == 159) THEN
    NDGL = 320
  ELSEIF(NSMAX == 199) THEN
    NDGL = 400
  ELSEIF(NSMAX == 255) THEN
    NDGL = 512
  ELSEIF(NSMAX == 319) THEN
    NDGL = 640
  ELSEIF(NSMAX == 399) THEN
    NDGL = 800
  ELSEIF(NSMAX == 511) THEN
    NDGL = 1024
  ELSEIF(NSMAX == 639) THEN
    NDGL = 1280
  ELSEIF(NSMAX == 799) THEN
    NDGL = 1600
  ELSEIF(NSMAX == 1023) THEN
    NDGL = 2048
  ELSEIF(NSMAX == 1279) THEN
    NDGL = 2560
  ELSEIF(NSMAX == 1599) THEN
    NDGL = 3200
  ELSEIF(NSMAX == 1999) THEN
    NDGL = 4000
  ELSEIF(NSMAX == 3999) THEN
    NDGL = 8000
  ELSEIF(NSMAX == 7999) THEN
    NDGL = 16000
  ELSE
    WRITE(NERR,*)'WRONG SPECTRAL RESOLUTION ',NSMAX,' CUBIC GRID'
    CALL ABOR1('TRANSFORM_TEST:UNSUPPORTED SPECTRAL RESOLUTION - CUBIC GRID ')
  ENDIF
ELSEIF (NLIN == 0) THEN
  IF(NSMAX == 21) THEN
    NDGL = 32
  ELSEIF(NSMAX == 42) THEN
    NDGL = 64
  ELSEIF(NSMAX == 63) THEN
    NDGL = 96
  ELSEIF(NSMAX == 106) THEN
    NDGL = 160
  ELSEIF(NSMAX == 213) THEN
    NDGL = 320
  ELSEIF(NSMAX == 341) THEN
    NDGL = 512
  ELSEIF(NSMAX == 426) THEN
    NDGL = 640
  ELSEIF(NSMAX == 533) THEN
    NDGL = 800
  ELSEIF(NSMAX == 682) THEN
    NDGL = 1024
  ELSEIF(NSMAX == 853) THEN
    NDGL = 1280
  ELSEIF(NSMAX == 1364) THEN
    NDGL = 2048
  ELSEIF(NSMAX == 1706) THEN
    NDGL = 2560
  ELSE
    WRITE(NERR,*)'WRONG SPECTRAL RESOLUTION ',NSMAX,' QUAD. GRID'
    CALL ABOR1('TRANSFORM_TEST:UNSUPPORTED SPECTRAL RESOLUTION - QUAD. GRID ')
  ENDIF
ELSEIF(NLIN == 1) THEN
  IF(NSMAX == 63) THEN
    NDGL = 64
  ELSEIF(NSMAX == 95) THEN
    NDGL = 96
  ELSEIF(NSMAX == 127) THEN
    NDGL = 128
  ELSEIF(NSMAX == 159) THEN
    NDGL = 160
  ELSEIF(NSMAX == 191) THEN
    NDGL = 192
  ELSEIF(NSMAX == 199) THEN
    NDGL = 200
  ELSEIF(NSMAX == 255) THEN
    NDGL = 256
  ELSEIF(NSMAX == 319) THEN
    NDGL = 320
  ELSEIF(NSMAX == 399) THEN
    NDGL = 400
  ELSEIF(NSMAX == 511) THEN
    NDGL = 512
  ELSEIF(NSMAX == 639) THEN
    NDGL = 640
  ELSEIF(NSMAX == 799) THEN
    NDGL = 800
  ELSEIF(NSMAX == 1023) THEN
    NDGL = 1024
  ELSEIF(NSMAX == 1279) THEN
    NDGL = 1280
  ELSEIF(NSMAX == 2047) THEN
    NDGL = 2048
  ELSEIF(NSMAX == 3999) THEN
    NDGL = 4000
  ELSEIF(NSMAX == 7999) THEN
    NDGL = 8000
  ELSE
    WRITE(NERR,*)'WRONG SPECTRAL RESOLUTION ',NSMAX,' LIN. GRID'
    CALL ABOR1('TRANSFORM_TEST:UNSUPPORTED SPECTRAL RESOLUTION - LIN. GRID')
  ENDIF
ELSE
  WRITE(NERR,*)'WRONG NLIN=',NLIN
  CALL ABOR1('TRANSFORM_TEST:WRONG NLIN')
ENDIF
END SUBROUTINE SETNDGL

!     ------------------------------------------------------------------

SUBROUTINE CHECK_NDGL

! Decide number of Gaussian latitudes given spectral truncation
! Only certain combinations of truncation/linear grid
! or quadratic grid are supported
 
IF(NLIN == 0) THEN
  IF(NDGL .ne.  32 .and. NDGL .ne.  64 .and. NDGL .ne.  96 .and. &
     NDGL .ne. 160 .and. NDGL .ne. 320 .and. NDGL .ne. 512 .and. &
     NDGL .ne. 640 .and. NDGL .ne. 800 .and. NDGL .ne. 1024 .and. NDGL .ne. 1280 ) THEN
    WRITE(NERR,*)'WRONG SPECTRAL RESOLUTION ',NSMAX,' QUAD. GRID'
!    CALL ABOR1('TRANSFORM_TEST:UNSUPPORTED SPECTRAL RESOLUTION - QUAD. GRID ')
  ENDIF
ELSEIF(NLIN == 1) THEN
  IF(NDGL .ne. 32 .and. NDGL .ne.  64 .and. NDGL .ne.  96 .and. NDGL .ne. 128 .and. &
     NDGL .ne. 160.and. NDGL .ne. 256 .and. NDGL .ne. 320 .and. NDGL .ne. 400 .and. &
     NDGL .ne. 512.and. NDGL .ne. 640 .and. NDGL .ne. 800 .and. NDGL .ne. 1024) THEN
    WRITE(NERR,*)'WRONG SPECTRAL RESOLUTION ',NSMAX,' LIN. GRID'
!    CALL ABOR1('TRANSFORM_TEST:UNSUPPORTED SPECTRAL RESOLUTION - LIN. GRID')
  ENDIF
ELSE
  WRITE(NERR,*)'WRONG NLIN=',NLIN
!  CALL ABOR1('TRANSFORM_TEST:WRONG NLIN')
ENDIF

END SUBROUTINE CHECK_NDGL

!     ------------------------------------------------------------------

SUBROUTINE SORT(A, N)
    IMPLICIT NONE
    INTEGER(KIND=JPIM) :: N, I, J
    REAL(KIND=JPRD)    :: A(N), X
 
    DO I = 2, N
        X = A(I)
        J = I - 1
        DO WHILE (J >= 1)
            IF (A(J) <= X) EXIT
            A(J + 1) = A(J)
            J = J - 1
        END DO
        A(J + 1) = X
    END DO
END SUBROUTINE

!     ------------------------------------------------------------------

SUBROUTINE DUMP_GRIDPOINT_FIELD_2D(JSTEP, MYPROC, FLD, FLDCHAR, NOUTDUMP)

! Dump a 2D field to a binary file.

INTEGER(KIND=JPIM), INTENT(IN) :: JSTEP ! Time step, used for naming file
INTEGER(KIND=JPIM), INTENT(IN) :: MYPROC ! MPI rank, used for naming file
REAL(KIND=JPRB)   , INTENT(IN) :: FLD(:,:) ! 2D field
CHARACTER         , INTENT(IN) :: FLDCHAR ! Single character field identifier
INTEGER(KIND=JPIM), INTENT(IN) :: NOUTDUMP ! Unit number for output file

CHARACTER(LEN=14) :: FILENAME = "X.XXX.XXXX.dat"

WRITE(FILENAME(1:1),'(A1)') FLDCHAR
WRITE(FILENAME(3:5),'(I3.3)') JSTEP
WRITE(FILENAME(7:10),'(I4.4)') MYPROC

OPEN(NOUTDUMP, FILE=FILENAME, FORM="UNFORMATTED")
WRITE(NOUTDUMP) FLD
CLOSE(NOUTDUMP)

END SUBROUTINE DUMP_GRIDPOINT_FIELD_2D
SUBROUTINE DUMP_GRIDPOINT_FIELD_3D(JSTEP, MYPROC, FLD, FLDCHAR, NOUTDUMP)

! Dump a 3D field to a binary file.

INTEGER(KIND=JPIM), INTENT(IN) :: JSTEP ! Time step, used for naming file
INTEGER(KIND=JPIM), INTENT(IN) :: MYPROC ! MPI rank, used for naming file
REAL(KIND=JPRB)   , INTENT(IN) :: FLD(:,:,:) ! 3D field
CHARACTER         , INTENT(IN) :: FLDCHAR ! Single character field identifier
INTEGER(KIND=JPIM), INTENT(IN) :: NOUTDUMP ! Unit number for output file

CHARACTER(LEN=14) :: FILENAME = "X.XXX.XXXX.dat"

WRITE(FILENAME(1:1),'(A1)') FLDCHAR
WRITE(FILENAME(3:5),'(I3.3)') JSTEP
WRITE(FILENAME(7:10),'(I4.4)') MYPROC

OPEN(NOUTDUMP, FILE=FILENAME, FORM="UNFORMATTED")
WRITE(NOUTDUMP) FLD
CLOSE(NOUTDUMP)

END SUBROUTINE DUMP_GRIDPOINT_FIELD_3D
SUBROUTINE DUMP_GRIDPOINT_FIELD_4D(JSTEP, MYPROC, FLD, FLDCHAR, NOUTDUMP)

! Dump a 4D field to a binary file.

INTEGER(KIND=JPIM), INTENT(IN) :: JSTEP ! Time step, used for naming file
INTEGER(KIND=JPIM), INTENT(IN) :: MYPROC ! MPI rank, used for naming file
REAL(KIND=JPRB)   , INTENT(IN) :: FLD(:,:,:,:) ! 4D field
CHARACTER         , INTENT(IN) :: FLDCHAR ! Single character field identifier
INTEGER(KIND=JPIM), INTENT(IN) :: NOUTDUMP ! Unit number for output file

CHARACTER(LEN=14) :: FILENAME = "X.XXX.XXXX.dat"

WRITE(FILENAME(1:1),'(A1)') FLDCHAR
WRITE(FILENAME(3:5),'(I3.3)') JSTEP
WRITE(FILENAME(7:10),'(I4.4)') MYPROC

OPEN(NOUTDUMP, FILE=FILENAME, FORM="UNFORMATTED")
WRITE(NOUTDUMP) FLD
CLOSE(NOUTDUMP)

END SUBROUTINE DUMP_GRIDPOINT_FIELD_4D

END PROGRAM TRANSFORM_TEST
